[{"path":"index.html","id":"welcome","chapter":"1 Welcome","heading":"1 Welcome","text":"","code":""},{"path":"index.html","id":"about-this-handbook","chapter":"1 Welcome","heading":"1.1 About this handbook","text":"ObjectiveA free open-access digital R reference book catered epidemiologists public health practitioners usable offline addresses common epidemiological tasks via clear text explanations, step--step instructions, best practice R code examplesEpis using R must often Google search read dozens forum pages complete common data manipulation visualization epi tasks. However, field epidemiologists often work low internet-connectivity environments limited technical support. handbook aims fill gap.read handbook:HTML file can viewed offline, best viewed Google Chrome.HTML file can viewed offline, best viewed Google Chrome.Search via search box Table Contents. Ctrl+f search across current page.Search via search box Table Contents. Ctrl+f search across current page.Click “clipboard” icon upper-right code chunk copy .Click “clipboard” icon upper-right code chunk copy .Version\r\nlatest version handbook can found github repository.","code":""},{"path":"index.html","id":"acknowledgements","chapter":"1 Welcome","heading":"1.2 Acknowledgements","text":"","code":""},{"path":"index.html","id":"contributors","chapter":"1 Welcome","heading":"1.2.1 Contributors","text":"Editor--Chief: Neale Batra (neale.batra@gmail.com)Editorial core team: …Authors: …Reviewers: …Advisers …","code":""},{"path":"index.html","id":"funding-and-programmatic-support","chapter":"1 Welcome","heading":"1.2.2 Funding and programmatic support","text":"TEPHINET\r\nEAN","code":""},{"path":"index.html","id":"data-sources","chapter":"1 Welcome","heading":"1.2.3 Data sources","text":"outbreaks R package","code":""},{"path":"index.html","id":"inspiration-and-templates","chapter":"1 Welcome","heading":"1.2.4 Inspiration and templates","text":"R4Epis\r\nRECON packages\r\nR4DS book (Hadley)\r\nBookdown book (Yihui)\r\nRmarkdown book (Yihui)","code":""},{"path":"index.html","id":"image-credits","chapter":"1 Welcome","heading":"1.2.5 Image credits","text":"Logo: CDC Public Image gallery; R Graph Gallery","code":""},{"path":"style-and-editorial-notes.html","id":"style-and-editorial-notes","chapter":"2 Style and editorial notes","heading":"2 Style and editorial notes","text":"","code":""},{"path":"style-and-editorial-notes.html","id":"style","chapter":"2 Style and editorial notes","heading":"2.1 Style","text":"","code":""},{"path":"style-and-editorial-notes.html","id":"text-style","chapter":"2 Style and editorial notes","heading":"2.1.1 Text style","text":"Package function namesPackage names written bold (e.g. dplyr) functions written like : mutate(). Packages referenced either text within code like : dplyr::mutate()Types notesNOTE: noteTIP: tip.CAUTION: cautionary note.DANGER: warning.","code":""},{"path":"style-and-editorial-notes.html","id":"tidyverse","chapter":"2 Style and editorial notes","heading":"2.1.2 tidyverse","text":"handbook generally uses tidyverse R coding style. Read ","code":""},{"path":"style-and-editorial-notes.html","id":"code-readability","chapter":"2 Style and editorial notes","heading":"2.1.3 Code readability","text":"chose frequently write code new lines, order offer understandable comments. result, code written like :…often written like :","code":"\nobs %>% \n  group_by(name) %>%                    # group the rows by 'name'\n  slice_max(date, n = 1, with_ties = F) # if there's a tie (of date), take the first row\nobs %>% \n  group_by(name) %>%   # group the rows by 'name'\n  slice_max(\n    date,              # keep row per group with maximum date value \n    n = 1,             # keep only the single highest row \n    with_ties = F)     # if there's a tie (of date), take the first row"},{"path":"style-and-editorial-notes.html","id":"editorial-decisions","chapter":"2 Style and editorial notes","heading":"2.2 Editorial decisions","text":", track significant editorial decisions around package function choice. disagree want offer new tool, please join/start conversation Github page.Table package, function, editorial decisions","code":""},{"path":"datasets-used.html","id":"datasets-used","chapter":"3 Datasets used","heading":"3 Datasets used","text":"datasets used handbook described downloadableLinelist (…)Aggregated case counts (…)GIS shapefile (…)modeling dataset? (…)","code":""},{"path":"cleaning-data.html","id":"cleaning-data","chapter":"4 Cleaning data","heading":"4 Cleaning data","text":"","code":""},{"path":"cleaning-data.html","id":"overview","chapter":"4 Cleaning data","heading":"4.1 Overview","text":"page demonstrates common steps necessary clean dataset. uses simulated Ebola case linelist, used throughout handbook.Dealing character case (upper, lower, title, etc.)Factor columnsreplace missing \r\ndealing cases (lower, etc)\r\ncase_when()\r\nfactors","code":""},{"path":"cleaning-data.html","id":"preparation","chapter":"4 Cleaning data","heading":"4.2 Preparation","text":"","code":""},{"path":"cleaning-data.html","id":"load-packages","chapter":"4 Cleaning data","heading":"4.2.1 Load packages","text":"","code":"\npacman::p_load(tidyverse,  # data manipulation and visualization\n               janitor,    # data cleaning\n               rio,        # importing data\n               epikit)     # age_categories() function  "},{"path":"cleaning-data.html","id":"load-data","chapter":"4 Cleaning data","heading":"4.2.2 Load data","text":"Import raw dataset using import() function package rio. (LINK IMPORT PAGE)can view first 50 rows original “raw” dataset :","code":"## New names:\r\n## * `` -> ...25\nlinelist_raw <- import(\"linelist_raw.xlsx\")"},{"path":"cleaning-data.html","id":"cleaning-pipeline","chapter":"4 Cleaning data","heading":"4.3 Cleaning pipeline","text":"epidemiological analysis data processing, cleaning steps often performed together sequentially. R often manifests cleaning “pipeline”, raw dataset passed “piped” one cleaning step another. chain utilizes dplyr verbs magrittr pipe operator (see handbook page dplyr tidyverse coding style (LINK ). pipe begins “raw” data (linelist_raw) ends “clean” dataset (linelist).cleaning pipeline order steps important. Cleaning steps might include:Importing dataColumn names cleaned changedRows filtered, added, de-duplicatedColumns selected, added, transformed, re-orderedValues re-coded, cleaned, grouped","code":""},{"path":"cleaning-data.html","id":"column-names","chapter":"4 Cleaning data","heading":"4.4 Column names","text":"Column names used often need “clean” syntax. suggest following:Short namesNo spaces (replaced underscores (_),unusual characters (&, #…)Similar style nomenclature (e.g. date columns named like date_onset, date_report, date_death…)columns names linelist_raw . can see spaces. also different naming patterns dates (‘date onset’ ‘infection date’).Also note raw data, two final columns names two merged cells one name. import() function used name first two columns, assigned second column name “…23” empty (referring 23rd column).","code":"\nnames(linelist_raw)##  [1] \"row_num\"         \"case_id\"         \"generation\"      \"infection date\" \r\n##  [5] \"date onset\"      \"hosp date\"       \"date_of_outcome\" \"outcome\"        \r\n##  [9] \"gender\"          \"hospital\"        \"lon\"             \"lat\"            \r\n## [13] \"infector\"        \"source\"          \"age\"             \"ct_blood\"       \r\n## [17] \"age_unit\"        \"fever\"           \"chills\"          \"cough\"          \r\n## [21] \"aches\"           \"vomit\"           \"time_admission\"  \"merged_header\"  \r\n## [25] \"...25\"Note: For a column name that include spaces, surround the name with back-ticks, for example: linelist$`infection date`. On a keyboard, the back-tick (`) is different from the single quotation mark ('), and is sometimes on the same key as the tilde (~)."},{"path":"cleaning-data.html","id":"automatic-colummn-name-cleaning","chapter":"4 Cleaning data","heading":"4.4.1 Automatic colummn name cleaning","text":"function clean_names() package janitor standardizes column names makes unique following:Converts names consist underscores, numbers, lettersAccented characters transliterated ASCII (e.g. german o umlaut becomes “o”, spanish “enye” becomes “n”)Capitalization preference can specified using case = argument (“snake” default, alternatives include “sentence”, “title”, “small_camel”…)can designate specific name replacements replace = argument (e.g. replace = c(onset = “date_of_onset”))online vignetteBelow, cleaning pipeline begins using clean_names() raw linelist.NOTE: column name “…25” changed “x25”.","code":"\n# send the dataset through the function clean_names()\nlinelist <- linelist_raw %>% \n  janitor::clean_names()\n\n# see the new names\nnames(linelist)##  [1] \"row_num\"         \"case_id\"         \"generation\"      \"infection_date\" \r\n##  [5] \"date_onset\"      \"hosp_date\"       \"date_of_outcome\" \"outcome\"        \r\n##  [9] \"gender\"          \"hospital\"        \"lon\"             \"lat\"            \r\n## [13] \"infector\"        \"source\"          \"age\"             \"ct_blood\"       \r\n## [17] \"age_unit\"        \"fever\"           \"chills\"          \"cough\"          \r\n## [21] \"aches\"           \"vomit\"           \"time_admission\"  \"merged_header\"  \r\n## [25] \"x25\""},{"path":"cleaning-data.html","id":"manual-column-name-cleaning","chapter":"4 Cleaning data","heading":"4.4.2 Manual column name cleaning","text":"Re-naming columns manually often necessary. , re-naming performed using rename() function dplyr package, part pipe chain. rename() uses style “NEW = OLD”, new column name given old column name., re-name command added cleaning pipeline:Now can see columns names changed:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome)"},{"path":"cleaning-data.html","id":"rename-by-column-position","chapter":"4 Cleaning data","heading":"4.4.2.1 Rename by column position","text":"can also rename column position, instead column name, example:","code":"\nrename(newNameForFirstColumn = 1,\n       newNameForSecondColumn = 2)"},{"path":"cleaning-data.html","id":"empty-excel-column-names","chapter":"4 Cleaning data","heading":"4.4.2.2 Empty Excel column names","text":"importing Excel sheet missing column name, depending import function used, R likely create column name value like “…1” “…2”. can clean names manually referencing position number (see ), name (linelist_raw$...1).","code":""},{"path":"cleaning-data.html","id":"merged-excel-column-names","chapter":"4 Cleaning data","heading":"4.4.3 Merged Excel column names","text":"Merged cells Excel file common occurrence receiving data field level. Merged cells can nice human reading data, cause many problems machine reading data. R accommodate merged cells.Remind people data entry human-readable data machine-readable data. Strive train users princiles tidy data. possible, try change procedures data arrive tidy format without merged cells.variable must column.observation must row.value must cell.using rio’s import() function, value merged cell assigned first cell subsequent cells empty.One solution deal merged cells import data function readWorkbook() package openxlsx. Set argument fillMergedCells = TRUE. gives value merged cell cells within merge range.DANGER: column names merged, end duplicate column names, need fix manually - R work well duplicate column names! can re-name referencing position (e.g. column 5), explained section manual column name cleaning..","code":"\nlinelist_raw <- openxlsx::readWorkbook(\"linelist_raw.xlsx\", fillMergedCells = TRUE)"},{"path":"cleaning-data.html","id":"skip-import-of-rows","chapter":"4 Cleaning data","heading":"4.4.4 Skip import of rows","text":"Sometimes, may want avoid importing row data (e.g. column names, row 1).\r\ncan argument skip = using import() rio package .xlsx .csv file. Provide number rows want skip.Unfortunately skip = accepts one integer value, range (e.g. “2:10”). skip import specific rows consecutive top, consider importing multiple times using bind_rows() dplyr. See example skipping row 2.","code":"\nlinelist_raw <- import(\"linelist_raw.xlsx\", skip = 1)  # does not import header row"},{"path":"cleaning-data.html","id":"removing-a-second-header-row","chapter":"4 Cleaning data","heading":"4.4.4.1 Removing a second header row","text":"data may second row data, example “data dictionary” row (see example ).situation can problematic can result columns imported class “character”. solve , likely need import data twice.Import data order store correct column namesImport data , skipping first two rows (header second rows)Bind correct names onto reduced dataframeThe exact arguments used bind correct column names depends type data file (.csv, .tsv, .xlsx, etc.). using rio’s import() function, understand function rio uses import data, give appropriate argument skip lines /designate column names. See handbook page importing data (LINK) details rio.Excel files:CSV files:Backup option - changing column names separate commandBonus! second row data dictionary, can easily create proper data dictionary using gather() command tidyr package.\r\nsource: https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/","code":"\n# For excel files (remove 2nd row)\nlinelist_raw_names <- import(\"linelist_raw.xlsx\") %>% names()  # save true column names\n\n# import, skip row 2, assign to col_names =\nlinelist_raw <- import(\"linelist_raw.xlsx\", skip = 2, col_names = linelist_raw_names) \n# For csv files\nlinelist_raw_names <- import(\"linelist_raw.csv\") %>% names() # save true column names\n\n# note argument is 'col.names ='\nlinelist_raw <- import(\"linelist_raw.csv\", skip = 2, col.names = linelist_raw_names) \n# assign/overwrite headers using the base 'colnames()' function\ncolnames(linelist_raw) <- linelist_raw_names\nlibrary(tidyr)\nstickers_dict <- import(\"linelist_raw.xlsx\") %>% \n  clean_names() %>% \n  gather(variable_name, variable_description)\nstickers_dict"},{"path":"cleaning-data.html","id":"combine-two-header-rows","chapter":"4 Cleaning data","heading":"4.4.5 Combine two header rows","text":"cases, may want combine two header rows one. command define column names combination (pasting together) existing column names value underneath first row. Replace “df” name dataset.","code":"\nnames(df) <- paste(names(df), df[1, ], sep = \"_\")"},{"path":"cleaning-data.html","id":"select-or-re-order-columns","chapter":"4 Cleaning data","heading":"4.5 Select or re-order columns","text":"CAUTION: tab may follow previous tabs.Often first step cleaning data selecting columns want work , set order dataframe. dplyr chain verbs, done select(). Note examples modify linelist select(), assign/overwrite. just display resulting new column names, purpose example.CAUTION: examples , linelist modified select() -written. New column names displayed purpose example.column names linelist:","code":"\nnames(linelist)##  [1] \"row_num\"              \"case_id\"              \"generation\"          \r\n##  [4] \"date_infection\"       \"date_onset\"           \"date_hospitalisation\"\r\n##  [7] \"date_outcome\"         \"outcome\"              \"gender\"              \r\n## [10] \"hospital\"             \"lon\"                  \"lat\"                 \r\n## [13] \"infector\"             \"source\"               \"age\"                 \r\n## [16] \"ct_blood\"             \"age_unit\"             \"fever\"               \r\n## [19] \"chills\"               \"cough\"                \"aches\"               \r\n## [22] \"vomit\"                \"time_admission\"       \"merged_header\"       \r\n## [25] \"x25\""},{"path":"cleaning-data.html","id":"select-re-order","chapter":"4 Cleaning data","heading":"4.5.1 Select & re-order","text":"Select columns want remain, order appearanceIndicate columns remove placing minus symbol “-” front column name (e.g. select(-outcome)), vector column names (). columns retained. Inside select() can use normal operators c() list several columns, : consecutive columns, ! opposite, & , | .Re-order columns - use everything() signify columns specified select() command:well everything() several special functions work within select(), namely:everything() - columns mentionedlast_col() - last columnwhere() - applies function columns selects TRUEstarts_with() - matches specified prefix. Example: select(starts_with(\"date\"))ends_with() - matches specified suffix. Example: select(ends_with(\"_end\"))contains() - columns containing character string. Example: select(contains(\"time\"))matches() - apply regular expression (regex). Example: select(contains(\"[pt]al\"))num_range() -any_of() - matches column named. Useful name might exist. Example: select(any_of(date_onset, date_death, cardiac_arrest))example using ():","code":"\n# linelist dataset is piped through select() command, and names() prints just the column names\nlinelist %>% \n  select(case_id, date_onset, date_hospitalisation, fever) %>% \n  names() # display the column names## [1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\"\r\n## [4] \"fever\"\nlinelist %>% \n  select(-c(date_onset, fever:vomit)) %>% # remove onset and all symptom columns\n  names()##  [1] \"row_num\"              \"case_id\"              \"generation\"          \r\n##  [4] \"date_infection\"       \"date_hospitalisation\" \"date_outcome\"        \r\n##  [7] \"outcome\"              \"gender\"               \"hospital\"            \r\n## [10] \"lon\"                  \"lat\"                  \"infector\"            \r\n## [13] \"source\"               \"age\"                  \"ct_blood\"            \r\n## [16] \"age_unit\"             \"time_admission\"       \"merged_header\"       \r\n## [19] \"x25\"\n# move case_id, date_onset, date_hospitalisation, and gender to beginning\nlinelist %>% \n  select(case_id, date_onset, date_hospitalisation, gender, everything()) %>% \n  names()##  [1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\"\r\n##  [4] \"gender\"               \"row_num\"              \"generation\"          \r\n##  [7] \"date_infection\"       \"date_outcome\"         \"outcome\"             \r\n## [10] \"hospital\"             \"lon\"                  \"lat\"                 \r\n## [13] \"infector\"             \"source\"               \"age\"                 \r\n## [16] \"ct_blood\"             \"age_unit\"             \"fever\"               \r\n## [19] \"chills\"               \"cough\"                \"aches\"               \r\n## [22] \"vomit\"                \"time_admission\"       \"merged_header\"       \r\n## [25] \"x25\"\n# select columns containing certain characters\nlinelist %>% \n  select(contains(\"date\")) %>% \n  names()## [1] \"date_infection\"       \"date_onset\"           \"date_hospitalisation\"\r\n## [4] \"date_outcome\"\n# searched for multiple character matches\nlinelist %>% \n  select(matches(\"onset|hosp|fev\")) %>%   # note the OR symbol \"|\"\n  names()## [1] \"date_onset\"           \"date_hospitalisation\" \"hospital\"            \r\n## [4] \"fever\""},{"path":"cleaning-data.html","id":"select-as-a-stand-alone-command","chapter":"4 Cleaning data","heading":"4.5.2 select() as a stand-alone command","text":"Select can also used independent command (pipe chain). case, first argument original dataframe operated upon.","code":"\n# Create a new linelist with id and age-related columns\nlinelist_age <- select(linelist, case_id, contains(\"age\"))\n\n# display the column names\nnames(linelist_age)## [1] \"case_id\"  \"age\"      \"age_unit\""},{"path":"cleaning-data.html","id":"add-to-the-pipe-chain","chapter":"4 Cleaning data","heading":"4.5.3 Add to the pipe chain","text":"linelist, columns need: row_num, merged_header, x25. Remove adding select() command cleaning pipe chain:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x25))"},{"path":"cleaning-data.html","id":"Classes","chapter":"4 Cleaning data","heading":"4.6 Modify class","text":"CAUTION: tab may follow previous tabs.See section object classesOften need set correct class column. common approach use mutate() define column , different class. Generally, looks like :","code":"\n# Examples of modifying class\nlinelist <- linelist %>% \n  mutate(date_var      = as.Date(date_var, format = \"MM/DD/YYYY\"),  # format should be the format of the raw data\n         numeric_var   = as.numeric(numeric_var),\n         character_var = as.character(character_var),\n         factor_var    = factor(factor_var, levels = c(), labels = c())\n         )"},{"path":"cleaning-data.html","id":"pre-checks-and-errors","chapter":"4 Cleaning data","heading":"4.6.1 Pre-checks and errors","text":"First run checks classes important columns.class “age” column character. perform analysis, need numbers recognized numeric!class “date_onset” column also character! perform analysis, dates must recognized dates!However, try classify date_onset column date, get error. Use table() sort another method examine values identify different one. example dataset see see one date_onset value entered different format (15th April 2014) values!can classify “date_onset” date, value must fixed format others. can fix date source data, , can cleaning pipeline via mutate() recode(). must done commands convert class Date. (LINK DATE SECTION).mutate() line can read : “mutate date_onset equal date_onset recoded OLD VALUE changed NEW VALUE”. Note pattern (OLD = NEW) recode() opposite R patterns (new = old). R development community working revising recoding.Especially converting class date, check data visually table() confirm converted correctly! .Date(), format = argument often source errors.","code":"\nclass(linelist$age)## [1] \"character\"\nclass(linelist$date_onset)## [1] \"character\"## \r\n## 15th April 2014      2012-05-03      2012-05-06      2012-05-08      2012-05-16 \r\n##               1               1               1               1               1 \r\n##      2012-05-21 \r\n##               1\n# fix incorrect values                 # old value       # new value\nmutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\"))"},{"path":"cleaning-data.html","id":"modify-multiple-columns","chapter":"4 Cleaning data","heading":"4.6.2 Modify multiple columns","text":"can use dplyr function across() mutate() convert several columns new class. across() allows specify columns want function apply . , want mutate columns .POSIXct() (type date/time class shows unnecessary timestamps) TRUE, apply function .Date() , order convert class “date”.Note within across() also use function ().Note .POSIXct package lubridate. similar functions (.character(), .numeric(), .logical()) base RNote functions across() written without empty parentheses (), described cleaning steps added pipe chain.","code":"\nlinelist <- linelist %>% \n  mutate(across(where(lubridate::is.POSIXct), as.Date))\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n  \n    # remove column\n    select(-c(row_num, merged_header, x25)) %>% \n\n  \n# ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n  ###################################################\n\n    # fix incorrect values                 # old value       # new value\n    mutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\")) %>% \n  \n    # correct the class of the columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) "},{"path":"cleaning-data.html","id":"add-columns-and-rows","chapter":"4 Cleaning data","heading":"4.7 Add columns and rows","text":"See tabs add columns rows","code":""},{"path":"cleaning-data.html","id":"add-columns","chapter":"4 Cleaning data","heading":"4.7.1 Add columns","text":"","code":""},{"path":"cleaning-data.html","id":"mutate","chapter":"4 Cleaning data","heading":"4.7.1.1 mutate()","text":"advise creating new columns dplyr functions part chain verb functions (e.g. filter, mutate, etc.)\r\nneed stand-alone command, can use mutate() base R style create new column (see ).verb mutate() used add new column, modify existing one. example creating new columns mutate(). syntax : new_column_name = value function.best practice separate new column comma new line. , practice columns created:Scroll right see new columns (first 50 rows):TIP: verb transmute() adds new columns just like mutate() also drops/removes columns mention.","code":"\nlinelist <- linelist %>% \n  mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset))\nlinelist <- linelist %>%                       # creating new, or modifying old dataset\n  mutate(new_var_dup    = case_id,             # new column = duplicate/copy another column\n         new_var_static = 7,                   # new column = all values the same\n         new_var_static = new_var_static + 5,  # you can overwrite a column, and it can be a calculation using other variables\n         new_var_paste  = stringr::str_glue(\"{hospital} on ({date_hospitalisation})\") # new column = pasting together values from other columns\n         ) "},{"path":"cleaning-data.html","id":"new-columns-using-base-r","chapter":"4 Cleaning data","heading":"4.7.1.2 New columns using base R","text":"define new column (re-define column) using base R, just use assignment operator .\r\nRemember using base R must specify dataframe writing column name (e.g. dataframe$column). two dummy examples:","code":"\nlinelist$old_var <- linelist$old_var + 7\nlinelist$new_var <- linelist$old_var + linelist$age"},{"path":"cleaning-data.html","id":"add-rows","chapter":"4 Cleaning data","heading":"4.7.2 Add rows","text":"DORemember column must contain values one class (either character, numeric, logical, etc.). adding row requires nuance maintain .use ... .= 3 put 3rd row. Default add end. columns specified let empty.\r\nnew row number may look strange (“…23”) row numbers changed. using command twice examine/test carefully.class see error like : Error: Can’t combine ..1$infection date  ..2$infection date .\r\n(date value remember wrap date functionas.Date() like .Date(\"2020-10-10\"))","code":"\nlinelist <- linelist %>% \n  add_row(row_num = 666, case_id = \"abc\", generation = 4, `infection date` = as.Date(\"2020-10-10\"), .before = 2)"},{"path":"cleaning-data.html","id":"new-columns-using-grouped-values","chapter":"4 Cleaning data","heading":"4.7.3 New columns using grouped values","text":"CAUTION: tab may follow previous tabs.Using mutate GROUPED dataframes\r\nhttps://dplyr.tidyverse.org/reference/mutate.htmlTaken website :","code":"#Because mutating expressions are computed within groups, they may yield different results on grouped tibbles. This will be the case as #soon as an aggregating, lagging, or ranking function is involved. Compare this ungrouped mutate:\r\n\r\nstarwars %>%\r\n  select(name, mass, species) %>%\r\n  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))\r\nWith the grouped equivalent:\r\n\r\nstarwars %>%\r\n  select(name, mass, species) %>%\r\n  group_by(species) %>%\r\n  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))\r\nThe former normalises mass by the global average whereas the latter normalises by the averages within species levels."},{"path":"cleaning-data.html","id":"add-to-pipe-chain","chapter":"4 Cleaning data","heading":"4.7.4 Add to pipe chain","text":"","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n  \n    # remove column\n    select(-c(row_num, merged_header, x25)) %>% \n\n    # fix incorrect values                 # old value       # new value\n    mutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\")) %>% \n    \n    # correct the class of the columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n\n  # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n  ###################################################\n\n  # create column: delay to hospitalisation\n  mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset))"},{"path":"cleaning-data.html","id":"recode","chapter":"4 Cleaning data","heading":"4.8 Recoding values","text":"example, linelist values column “hospital” must cleaned. several different spellings (often word “Hospital” missing “s” written “Hopital”), many missing values.","code":"\ntable(linelist$hospital, useNA = \"always\")## \r\n##                      Central Hopital                     Central Hospital \r\n##                                   11                                  451 \r\n##                           Hospital A                           Hospital B \r\n##                                  290                                  289 \r\n##                     Military Hopital                    Military Hospital \r\n##                                   30                                  805 \r\n##                     Mitylira Hopital                    Mitylira Hospital \r\n##                                    1                                   81 \r\n##                                Other                         Port Hopital \r\n##                                  904                                   47 \r\n##                        Port Hospital St. Mark's Maternity Hospital (SMMH) \r\n##                                 1770                                  418 \r\n##   St. Marks Maternity Hopital (SMMH)                                 <NA> \r\n##                                   11                                 1501"},{"path":"cleaning-data.html","id":"manual-recoding","chapter":"4 Cleaning data","heading":"4.8.1 Manual recoding","text":"tabs demonstrate re-coding values manually b providing specific spellings corrected:Using replace() specific rowsUsing recode() entire columnsUsing base R","code":""},{"path":"cleaning-data.html","id":"replace","chapter":"4 Cleaning data","heading":"4.8.1.1 replace()","text":"manually change values specific rows within dataframe (within pipe chain), use replace() within mutate().\r\nUse logic condition specify rows, example ID value one row. general syntax :mutate(col_to_change = replace(col_to_change, criteria rows, new value)).first example , gender value, row id “2195”, changed “Female”.","code":"# Example: change gender of one specific observation to \"Female\" \r\nmutate(gender = replace(gender, id == \"2195\", \"Female\")\r\n\r\n# Example: chance gender of one specific observation to NA \r\nmutate(gender = replace(gender, id == \"2195\", NA)"},{"path":"cleaning-data.html","id":"recode-1","chapter":"4 Cleaning data","heading":"4.8.1.2 recode()","text":"change spellings manually, one--one, can use recode() function *within mutate() function. code saying column “hospital” defined current column “hospital”, certain changes (syntax OLD = NEW). Don’t forget commas!Now see values hospital column corrected:TIP: number spaces equals sign matter. Make code easier read aligning = rows. Also, consider adding hashed comment row clarify future readers side OLD side NEW. TIP: Sometimes blank character value exists dataset (recognized R’s value missing - NA). can reference value two quotation marks space inbetween (\"\").","code":"\nlinelist <- linelist %>% \n  mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      ))\ntable(linelist$hospital, useNA = \"always\")## \r\n##                     Central Hospital                           Hospital A \r\n##                                  462                                  290 \r\n##                           Hospital B                    Military Hospital \r\n##                                  289                                  917 \r\n##                                Other                        Port Hospital \r\n##                                  904                                 1817 \r\n## St. Mark's Maternity Hospital (SMMH)                                 <NA> \r\n##                                  429                                 1501"},{"path":"cleaning-data.html","id":"base-r","chapter":"4 Cleaning data","heading":"4.8.1.3 base R","text":"necessary, make manual changes specific value dataframe referencing row number case ID. remember better can make changes permanently underlying data!fake example. reads “Change value dataframe linelist‘s column onset_date (row linelist’s column case_id value ’9d4019’) .Date(\"2020-10-24\")”.","code":"\nlinelist$date_onset[linelist$case_id == \"9d4019\"] <- as.Date(\"2020-10-24\")"},{"path":"cleaning-data.html","id":"recoding-by-logic","chapter":"4 Cleaning data","heading":"4.8.2 Recoding by logic","text":"tabs demonstrate re-coding values column using logic conditions:Using case_when()Using ifelse() if_else()Using special dplyr recoding functions like:\r\nreplace_na()\r\nna_if()\r\ncoalesnce()\r\nreplace_na()na_if()coalesnce()","code":""},{"path":"cleaning-data.html","id":"case_when","chapter":"4 Cleaning data","heading":"4.8.2.1 case_when()","text":"need use logic statements recode values, want use operators like %%, use dplyr’s case_when() instead. use case_when() please read thorough explanation LINK, important differences recode() syntax logic order!Note Right-hand side (RHS) inputs must class (e.g. character, numeric, logical). Notice use special value NA_real_ instead just NA.","code":"\nlinelist <- linelist %>% \n  dplyr::mutate(age_years = case_when(\n            age_unit == \"years\"  ~ age,       # if age is given in years\n            age_unit == \"months\" ~ age/12,    # if age is given in months\n            is.na(age_unit)      ~ age,       # if age unit is missing, assume years\n            TRUE                 ~ NA_real_)) # Any other circumstance"},{"path":"cleaning-data.html","id":"ifelse-and-if_else","chapter":"4 Cleaning data","heading":"4.8.2.2 ifelse() and if_else()","text":"simple uses logical re-coding new variable creationgyou can use ifelse() if_else(). Though cases better use case_when().commands simplified versions else statement. general syntax ifelse(condition, value condition evaluates TRUE, value condition evaluates FALSE). used mutate(), row evaluated. if_else() special version dplyr handles dates condition.can tempting string together many ifelse commands… resist use case_when() instead! much simple, easier read, easier identify errors.IMAGE ifelse string X across .can reference columns ifelse() function within mutate():Example ifelse():Example if_else() (using dates):\r\nNote ‘true’ value date, ‘false’ value must also qualify date, hence using special character NA_real_ instead just NA.Note: want alternate value used code based circumstances, consider using switch() base R. example … . See section using switch() page R interactive console.","code":"\nlinelist <- linelist %>% \n  mutate(source_known = ifelse(!is.na(source), \"known\", \"unknown\"))\nlinelist <- linelist %>% \n  mutate(date_death = if_else(outcome == \"Death\", date_outcome, NA_real_))"},{"path":"cleaning-data.html","id":"recoding-using-special-dplyr-functions","chapter":"4 Cleaning data","heading":"4.8.3 Recoding using special dplyr functions","text":"","code":""},{"path":"cleaning-data.html","id":"using-replace_na","chapter":"4 Cleaning data","heading":"4.8.3.1 Using replace_na()","text":"change missing values (NA) specific character value, “Missing”, use function replace_na() within mutate(). Note used manner recode - name variable must repeated within replace_na().","code":"\nlinelist <- linelist %>% \n  mutate(hospital = replace_na(hospital, \"Missing\"))"},{"path":"cleaning-data.html","id":"using-na_if","chapter":"4 Cleaning data","heading":"4.8.3.2 Using na_if()","text":"Likewise can quickly convert specific character value NA using na_if(). command opposite one . converts values “Missing” NA.","code":"\nlinelist <- linelist %>% \n  mutate(hospital = na_if(hospital, \"Missing\"))"},{"path":"cleaning-data.html","id":"using-coalesce","chapter":"4 Cleaning data","heading":"4.8.3.3 Using coalesce()","text":"dplyr function finds first non-missing value position. , provide columns row fill value first non-missing value columns provided.example, might use thiscoalesce()` create “location” variable hypothetical variables “patient_residence” “reporting_jurisdiction”, prioritize patient residence information, exists.\r\nlead(), lag()\r\ncumsum(), cummean(), cummin(), cummax(), cumany(), cumall(),","code":"\nlinelist <- linelist %>% \n  mutate(location = coalesce(patient_residence, reporting_jurisdiction))"},{"path":"cleaning-data.html","id":"recoding-using-cleaning-dictionaries","chapter":"4 Cleaning data","heading":"4.8.4 Recoding using cleaning dictionaries","text":"CAUTION: tab may follow previous tabs.","code":"\n## load cleaning rules and only keep columns in mll\nmll_cleaning_rules <- import(here(\"dictionaries/mll_cleaning_rules.xlsx\")) %>%\n  filter(column %in% c(names(mll_raw), \".global\"))\n\n## define columns that are not cleand\nunchanged <- c(\n  \"epilink_relationship\",\n  \"narratives\",\n  \"epilink_relationship_detail\"\n)\n\nmll_clean <- mll_raw %>%\n  ## convert to tibble\n  as_tibble() %>%\n  ## clean columns using cleaning rules\n  clean_data(\n    wordlists = mll_cleaning_rules,\n    protect = names(.) %in% unchanged\n  )"},{"path":"cleaning-data.html","id":"add-to-pipe-chain-1","chapter":"4 Cleaning data","heading":"4.8.5 Add to pipe chain","text":"add described cleaning steps pipe chain.","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n  \n    # remove column\n    select(-c(row_num, merged_header, x25)) %>% \n\n    # fix incorrect values                 # old value       # new value\n    mutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\")) %>% \n    \n    # correct the class of the columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n  \n    # create column: delay to hospitalisation\n  mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n\n# ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n  ###################################################\n\n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_))"},{"path":"cleaning-data.html","id":"filter-rows","chapter":"4 Cleaning data","heading":"4.9 Filter rows","text":"CAUTION: tab may follow previous tabs.typical early cleaning step filter dataframe specific rows using dplyr verb filter(). Within filter(), give logic must TRUE row dataset kept.tabs show filter rows based simple complex logical conditions, filter/subset rows stand-alone command base R","code":""},{"path":"cleaning-data.html","id":"a-simple-filter","chapter":"4 Cleaning data","heading":"4.9.1 A simple filter()","text":"simple example re-defines dataframe linelist , filtered rows meet logical condition. rows logical statement within parentheses TRUE kept.case, logical statement !.na(case_id), asking whether value column case_id missing (NA). Thus, rows case_id missing kept.filter applied, number rows linelist 6609.filter applied, number rows linelist 6603.","code":"\nlinelist <- linelist %>% \n  filter(!is.na(case_id))  # keep only rows where case_id is not missing"},{"path":"cleaning-data.html","id":"a-complex-filter","chapter":"4 Cleaning data","heading":"4.9.2 A complex filter()","text":"complex example using filter():","code":""},{"path":"cleaning-data.html","id":"examine-the-data","chapter":"4 Cleaning data","heading":"4.9.2.1 Examine the data","text":"simple one-line command create histogram onset dates. See second smaller outbreak 2012-2013 also included dataset. analyses, want remove entries earlier outbreak.","code":"\nhist(linelist$date_onset, breaks = 50)"},{"path":"cleaning-data.html","id":"how-filters-handle-missing-numeric-and-date-values","chapter":"4 Cleaning data","heading":"4.9.2.2 How filters handle missing numeric and date values","text":"Can just filter date_onset rows June 2013? Caution! Applying code filter(date_onset > .Date(\"2013-06-01\"))) accidentally remove rows later epidemic missing date onset!DANGER: Filtering greater (>) less (<) date number can remove rows missing values (NA)! NA treated infinitely large small.","code":""},{"path":"cleaning-data.html","id":"design-the-filter","chapter":"4 Cleaning data","heading":"4.9.2.3 Design the filter","text":"Examine cross-tabulation make sure exclude correct rows:criteria can filter remove first outbreak dataset? see :first epidemic occurred Hospital , Hospital B, also 10 cases Port Hospital.Hospitals & B cases second epidemic, Port Hospital .want exclude:586 rows onset 2012 2013 either hospital , B, Port:\r\nExclude 586 rows onset 2012 2013\r\nExclude 0 rows Hospitals & B missing onset dates\r\nexclude 0 rows missing onset dates.\r\nExclude 586 rows onset 2012 2013Exclude 0 rows Hospitals & B missing onset datesDo exclude 0 rows missing onset dates.start linelist nrow(linelist). filter statement:re-make cross-tabulation, see Hospitals & B removed completely, 10 Port Hospital cases 2012 & 2013 removed, values - just wanted.Multiple statements can included within one filter command (separated commas), can always pipe separate filter() command clarity.Note: readers may notice easier just filter date_hospitalisation 100% complete. true. pdate_onset used purposes complex filter example.","code":"\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values##                                       YearOnset\r\n## Hospital                               2012 2013 2014 2015 <NA>\r\n##   Central Hospital                        0    0  366   96    0\r\n##   Hospital A                            225   65    0    0    0\r\n##   Hospital B                            220   66    0    0    0\r\n##   Military Hospital                       0    0  717  200    0\r\n##   Missing                                 0    0 1180  318    0\r\n##   Other                                   0    0  724  180    0\r\n##   Port Hospital                          10    0 1462  345    0\r\n##   St. Mark's Maternity Hospital (SMMH)    0    0  336   93    0\r\n##   <NA>                                    0    0    0    0    0\nlinelist <- linelist %>% \n  # keep rows where onset is after 1 June 2013 OR where onset is missing and it was a hospital OTHER than Hospital A or B\n  filter(date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))\n\nnrow(linelist)## [1] 6017\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values##                                       YearOnset\r\n## Hospital                               2014 2015 <NA>\r\n##   Central Hospital                      366   96    0\r\n##   Military Hospital                     717  200    0\r\n##   Missing                              1180  318    0\r\n##   Other                                 724  180    0\r\n##   Port Hospital                        1462  345    0\r\n##   St. Mark's Maternity Hospital (SMMH)  336   93    0\r\n##   <NA>                                    0    0    0"},{"path":"cleaning-data.html","id":"filter-as-a-stand-alone-command","chapter":"4 Cleaning data","heading":"4.9.3 Filter as a stand-alone command","text":"Filtering can also done stand-alone command (part pipe chain). Like dplyr verbs, case first argument must dataset .can also use base R subset using square brackets reflect [rows, columns] want retain.TIP: Use bracket-subset syntax View() quickly review records.","code":"\n# dataframe <- filter(dataframe, condition(s) for rows to keep)\n\nlinelist <- filter(linelist, !is.na(case_id))\n# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)\n\nlinelist <- linelist[!is.na(case_id), ]"},{"path":"cleaning-data.html","id":"filtering-to-quickly-review-data","chapter":"4 Cleaning data","heading":"4.9.4 Filtering to quickly review data","text":"base R syntax can handy want quickly view subset rows columns. Use base R View() command (note capital “V”) around [] subset want see. result appear dataframe RStudio viewer panel. example, want review onset hospitalization dates 3 specific cases:View linelist viewer panel:View specific data three cases:Note: command can also written dplyr verbs filter() select() :","code":"\nView(linelist)\nView(linelist[linelist$case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\"), c(\"date_onset\", \"date_hospitalisation\")])\nView(linelist %>%\n       filter(case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\")) %>%\n       select(date_onset, date_hospitalisation))"},{"path":"cleaning-data.html","id":"add-to-pipe-chain-2","chapter":"4 Cleaning data","heading":"4.9.5 Add to pipe chain","text":"","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n  \n    # remove column\n        select(-c(row_num, merged_header, x25)) %>% \n\n    # fix incorrect values                 # old value       # new value\n    mutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\")) %>% \n    \n    # correct the class of the columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n  \n    \n    # create column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n\n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\"  ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit)      ~ age,\n          TRUE                 ~ NA_real_)) %>% \n    \n  # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################\n    filter(\n          # keep only rows where case_id is not missing\n          !is.na(case_id),  \n          \n          # also filter to keep only the second outbreak\n          date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))"},{"path":"cleaning-data.html","id":"num_cats","chapter":"4 Cleaning data","heading":"4.10 Numeric categories","text":"CAUTION: tab may follow previous tabs.Special approaches creating numeric categoriesCommon examples include age categories, groups lab values, etc.several ways create categories numeric column age. discuss:age_categories(), epikit packagecut(), base Rusing percentiles break numbersnatural break points… ? DOcase_when()Sometimes, numeric variables import class “character”. occurs non-numeric characters values, example entry “2 months” age, (depending R locale settings) comma used decimals place (e.g. “4,5” mean four one half years).example create age_cat column using age_years column.","code":"\n#check the class of the linelist variable age\nclass(linelist$age_years)## [1] \"numeric\""},{"path":"cleaning-data.html","id":"age_categories","chapter":"4 Cleaning data","heading":"4.10.1 age_categories()**","text":"epikit package, can use age_categories() function easily categorize label numeric columns (note: can applied non-age numeric variables ). output ordered factor.break values specified included higher group, groups open lower/left side. shown , can add 1 break value achieve groups open top/right.optional arguments:lower = Default 0). lowest number want considered.upper = highest number want considered.= number years groups.separator = Default “-”. Character ages labels.ceiling = Default FALSE. TRUE, highest break value ceiling category “XX+” included. values highest break upper (defined) categorized NA.See function’s Help page details (enter ?age_categories R console).","code":"\nlibrary(epikit)\n\n# Simple example\n################\nlinelist <- linelist %>% \n  mutate(age_cat = age_categories(age_years,\n                                  breakers = c(0, 5, 10, 15, 20, 30, 50, 70)))\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-29 30-49 50-69   70+  <NA> \r\n##  1078  1181   981   908  1089   665    24     0    91\n# With ceiling set to TRUE\n##########################\nlinelist <- linelist %>% \n  mutate(age_cat = age_categories(age_years, \n                                  breakers = c(0, 5, 10, 15, 20, 30, 50, 70),\n                                  upper = max(linelist$age_years, na.rm=T),\n                                  ceiling = TRUE)) # 70 is the ceiling\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-29 30-49 50-70  <NA> \r\n##  1078  1181   981   908  1089   665    24    91\n# Include upper ends for the same categories\n############################################\nlinelist <- linelist %>% \n  mutate(age_cat = age_categories(age_years, \n                                  upper = max(linelist$age_years, na.rm=T),\n                                  breakers = c(0, 6, 11, 16, 21, 31, 51, 71, 76)))\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-5  6-10 11-15 16-20 21-30 31-50 51-70 71-75   76+  <NA> \r\n##  1328  1149   977   818  1035   599    20     0     0    91"},{"path":"cleaning-data.html","id":"cut","chapter":"4 Cleaning data","heading":"4.10.2 cut()","text":"can use base R function cut(), creates categories numeric variable. differences age_categories() :need install/load another packageYou can specify whether groups open/closed right/leftYou must provide labels (ensure accurate groups)want 0 included lowest group must specify thisThe basic syntax within cut() first provide numeric variable cut (age_years), breaks argument, numeric vector (c()) break points. Using cut(), resulting column ordered factor.used within mutate() (dplyr verb) necessary specify dataframe column name (e.g. linelist$age_years).","code":""},{"path":"cleaning-data.html","id":"simple-cut-example","chapter":"4 Cleaning data","heading":"4.10.2.1 Simple cut() example","text":"Create new column age categories (age_cat) cutting numeric age_year column specified break points. example replicates first age_categories() example.Specify numeric vector break points c(0, 5, 10, 15, ...)Default behavior cut() lower break values excluded category, upper break values included. opposite behavior age_categories() function.Include 0 lowest category adding include.lowest = TRUEAdd vector customized labels using labels = argumentCheck work cross-tabulation numeric category columns - aware missing values","code":"\nlinelist <- linelist %>% \n  mutate(age_cat = cut(age_years,                                       # numeric column\n                        breaks = c(0, 5, 10, 15, 20, 30, 50, 70,        # break points...\n                                   max(linelist$age_years, na.rm=T)),   # ... with dynamic last break as column max value\n                        right = TRUE,                                   # lower breaks included and upper excluded [a,b)\n                        include.lowest = TRUE,                          # 0 included in lowest category\n                        labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\",      # manual labels - be careful!\n                                   \"20-29\", \"30-49\", \"50-69\", \"70+\")))       \n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-29 30-49 50-69   70+  <NA> \r\n##  1328  1149   977   818  1035   599    20     0    91"},{"path":"cleaning-data.html","id":"cut-details","chapter":"4 Cleaning data","heading":"4.10.2.2 cut() details","text":"detailed description behavior using cut() make age_cat column. Key points:Inclusion/exclusion behavior break pointsCustom category labelsHandling missing valuesCheck work!simple command cut() applied age_years make new variable age_cat :default, categorization occurs right/upper side “open” inclusive (left/lower side “closed” exclusive). default labels use notation “(, B]”, means group include (lower break value), includes B (upper break value). Reverse behavior providing right = TRUE argument.default, categorization occurs right/upper side “open” inclusive (left/lower side “closed” exclusive). default labels use notation “(, B]”, means group include (lower break value), includes B (upper break value). Reverse behavior providing right = TRUE argument.Thus, default “0” values excluded lowest group, categorized NA. “0” values infants coded age 0. change add argument include.lowest = TRUE. , “0” values included lowest group. automatically-generated label lowest category change “(0,B]” “[0,B]”, signifies 0 values included.Thus, default “0” values excluded lowest group, categorized NA. “0” values infants coded age 0. change add argument include.lowest = TRUE. , “0” values included lowest group. automatically-generated label lowest category change “(0,B]” “[0,B]”, signifies 0 values included.Check work!!! Verify age value assigned correct category cross-tabulating numeric category columns. Examine assignment boundary values (e.g. 15, neighboring categories 10-15 15-20).Check work!!! Verify age value assigned correct category cross-tabulating numeric category columns. Examine assignment boundary values (e.g. 15, neighboring categories 10-15 15-20).Read cut() Help page entering ?cut R console.Reversing break inclusion behavior cut()Lower break values included category (upper break values excluded) argument right = included set TRUE. applied - note values shifted among categories.NOTE: include include.lowest = TRUE argument right = TRUE, include.lowest now apply highest break point value category, lowest.Re-labeling NA values cut()cut() automatically label NA values, may want assign label “Missing”. requires extra steps cut() automatically classified new column age_cat Factor (rigid column class specific value labels).First, convert age_cut Factor Character class, flexibility add new character values (e.g. “Missing”). Otherwise encounter error. , use dplyr verb replace_na() replace NA values character value like “Missing”. steps can combined one step, shown .Note Missing added, order categories now wrong (alphabetical).fix , re-convert age_cat factor, define order levels correctly.want fast way make breaks labels, can use something like (adjust specific situation). See page using seq() rep() c() ","code":"\n# Create new variable, by cutting the numeric age variable\n# by default, upper break is excluded and lower break excluded from each category\nlinelist <- linelist %>% \n  mutate(age_cat = cut(age_years, breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100)))\n\n# tabulate the number of observations per group\ntable(linelist$age_cat, useNA = \"always\")## \r\n##    (0,5]   (5,10]  (10,15]  (15,20]  (20,30]  (30,50]  (50,70] (70,100] \r\n##     1215     1149      977      818     1035      599       20        0 \r\n##     <NA> \r\n##      204\n# Cross tabulation of the numeric and category columns. \ntable(\"Numeric Values\" = linelist$age_years,   # names specified in table for clarity.\n      \"Categories\"     = linelist$age_cat,\n      useNA = \"always\")                        # don't forget to examine NA values##                     Categories\r\n## Numeric Values       (0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70]\r\n##   0                      0      0       0       0       0       0       0\r\n##   0.0833333333333333     2      0       0       0       0       0       0\r\n##   0.166666666666667      3      0       0       0       0       0       0\r\n##   0.25                   2      0       0       0       0       0       0\r\n##   0.333333333333333      2      0       0       0       0       0       0\r\n##   0.416666666666667      3      0       0       0       0       0       0\r\n##   0.5                    2      0       0       0       0       0       0\r\n##   0.583333333333333      1      0       0       0       0       0       0\r\n##   0.666666666666667      3      0       0       0       0       0       0\r\n##   0.75                   1      0       0       0       0       0       0\r\n##   0.833333333333333      1      0       0       0       0       0       0\r\n##   0.916666666666667      3      0       0       0       0       0       0\r\n##   1                    263      0       0       0       0       0       0\r\n##   1.5                    1      0       0       0       0       0       0\r\n##   2                    249      0       0       0       0       0       0\r\n##   3                    226      0       0       0       0       0       0\r\n##   4                    203      0       0       0       0       0       0\r\n##   5                    250      0       0       0       0       0       0\r\n##   6                      0    234       0       0       0       0       0\r\n##   7                      0    240       0       0       0       0       0\r\n##   8                      0    220       0       0       0       0       0\r\n##   9                      0    237       0       0       0       0       0\r\n##   10                     0    218       0       0       0       0       0\r\n##   11                     0      0     195       0       0       0       0\r\n##   12                     0      0     190       0       0       0       0\r\n##   13                     0      0     179       0       0       0       0\r\n##   14                     0      0     199       0       0       0       0\r\n##   15                     0      0     214       0       0       0       0\r\n##   16                     0      0       0     194       0       0       0\r\n##   17                     0      0       0     164       0       0       0\r\n##   18                     0      0       0     177       0       0       0\r\n##   19                     0      0       0     159       0       0       0\r\n##   20                     0      0       0     124       0       0       0\r\n##   21                     0      0       0       0     140       0       0\r\n##   22                     0      0       0       0     121       0       0\r\n##   23                     0      0       0       0     108       0       0\r\n##   24                     0      0       0       0      95       0       0\r\n##   25                     0      0       0       0     109       0       0\r\n##   26                     0      0       0       0     108       0       0\r\n##   27                     0      0       0       0      98       0       0\r\n##   28                     0      0       0       0     100       0       0\r\n##   29                     0      0       0       0      86       0       0\r\n##   30                     0      0       0       0      70       0       0\r\n##   31                     0      0       0       0       0      70       0\r\n##   32                     0      0       0       0       0      71       0\r\n##   33                     0      0       0       0       0      55       0\r\n##   34                     0      0       0       0       0      52       0\r\n##   35                     0      0       0       0       0      43       0\r\n##   36                     0      0       0       0       0      35       0\r\n##   37                     0      0       0       0       0      29       0\r\n##   38                     0      0       0       0       0      37       0\r\n##   39                     0      0       0       0       0      27       0\r\n##   40                     0      0       0       0       0      36       0\r\n##   41                     0      0       0       0       0      20       0\r\n##   42                     0      0       0       0       0      17       0\r\n##   43                     0      0       0       0       0      21       0\r\n##   44                     0      0       0       0       0      21       0\r\n##   45                     0      0       0       0       0      20       0\r\n##   46                     0      0       0       0       0      14       0\r\n##   47                     0      0       0       0       0       9       0\r\n##   48                     0      0       0       0       0       7       0\r\n##   49                     0      0       0       0       0      11       0\r\n##   50                     0      0       0       0       0       4       0\r\n##   51                     0      0       0       0       0       0       3\r\n##   52                     0      0       0       0       0       0       4\r\n##   53                     0      0       0       0       0       0       3\r\n##   55                     0      0       0       0       0       0       2\r\n##   56                     0      0       0       0       0       0       1\r\n##   58                     0      0       0       0       0       0       1\r\n##   59                     0      0       0       0       0       0       2\r\n##   62                     0      0       0       0       0       0       1\r\n##   63                     0      0       0       0       0       0       1\r\n##   65                     0      0       0       0       0       0       1\r\n##   66                     0      0       0       0       0       0       1\r\n##   <NA>                   0      0       0       0       0       0       0\r\n##                     Categories\r\n## Numeric Values       (70,100] <NA>\r\n##   0                         0  113\r\n##   0.0833333333333333        0    0\r\n##   0.166666666666667         0    0\r\n##   0.25                      0    0\r\n##   0.333333333333333         0    0\r\n##   0.416666666666667         0    0\r\n##   0.5                       0    0\r\n##   0.583333333333333         0    0\r\n##   0.666666666666667         0    0\r\n##   0.75                      0    0\r\n##   0.833333333333333         0    0\r\n##   0.916666666666667         0    0\r\n##   1                         0    0\r\n##   1.5                       0    0\r\n##   2                         0    0\r\n##   3                         0    0\r\n##   4                         0    0\r\n##   5                         0    0\r\n##   6                         0    0\r\n##   7                         0    0\r\n##   8                         0    0\r\n##   9                         0    0\r\n##   10                        0    0\r\n##   11                        0    0\r\n##   12                        0    0\r\n##   13                        0    0\r\n##   14                        0    0\r\n##   15                        0    0\r\n##   16                        0    0\r\n##   17                        0    0\r\n##   18                        0    0\r\n##   19                        0    0\r\n##   20                        0    0\r\n##   21                        0    0\r\n##   22                        0    0\r\n##   23                        0    0\r\n##   24                        0    0\r\n##   25                        0    0\r\n##   26                        0    0\r\n##   27                        0    0\r\n##   28                        0    0\r\n##   29                        0    0\r\n##   30                        0    0\r\n##   31                        0    0\r\n##   32                        0    0\r\n##   33                        0    0\r\n##   34                        0    0\r\n##   35                        0    0\r\n##   36                        0    0\r\n##   37                        0    0\r\n##   38                        0    0\r\n##   39                        0    0\r\n##   40                        0    0\r\n##   41                        0    0\r\n##   42                        0    0\r\n##   43                        0    0\r\n##   44                        0    0\r\n##   45                        0    0\r\n##   46                        0    0\r\n##   47                        0    0\r\n##   48                        0    0\r\n##   49                        0    0\r\n##   50                        0    0\r\n##   51                        0    0\r\n##   52                        0    0\r\n##   53                        0    0\r\n##   55                        0    0\r\n##   56                        0    0\r\n##   58                        0    0\r\n##   59                        0    0\r\n##   62                        0    0\r\n##   63                        0    0\r\n##   65                        0    0\r\n##   66                        0    0\r\n##   <NA>                      0   91\nlinelist <- linelist %>% \n  mutate(age_cat = cut(age_years,\n                          breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),     # same breaks\n                          right = FALSE,                                     # include each *lower* break point            \n                          labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\",\n                                     \"20-29\", \"30-49\", \"50-69\", \"70-100\")))  # now the labels must change\n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##    0-4    5-9  10-14  15-19  20-29  30-49  50-69 70-100   <NA> \r\n##   1078   1181    981    908   1089    665     24      0     91\nlinelist <- linelist %>% \n  \n  # cut() creates age_cat, automatically of class Factor      \n  mutate(age_cat = cut(age_years,\n                          breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n                          right = FALSE,                                                      \n                          labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\",\n                                     \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n         # convert to class Character, and replace NA with \"Missing\"\n         age_cat = replace_na(as.character(age_cat), \"Missing\"))\n\n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##     0-4   10-14   15-19   20-29   30-49     5-9   50-69 Missing    <NA> \r\n##    1078     981     908    1089     665    1181      24      91       0\nlinelist <- linelist %>% \n  \n  # cut() creates age_cat, automatically of class Factor      \n  mutate(age_cat = cut(age_years,\n                          breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n                          right = FALSE,                                                      \n                          labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\",\n                                     \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n         # convert to class Character, and replace NA with \"Missing\"\n         age_cat = replace_na(as.character(age_cat), \"Missing\"),\n         \n         # re-classify age_cat as Factor, with correct level order and new \"Missing\" level\n         age_cat = factor(age_cat, levels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-29\",\n                                              \"30-49\", \"50-69\", \"70-100\", \"Missing\")))    \n  \n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##     0-4     5-9   10-14   15-19   20-29   30-49   50-69  70-100 Missing    <NA> \r\n##    1078    1181     981     908    1089     665      24       0      91       0\n# Make break points from 0 to 90 by 5\nage_seq = seq(from = 0, to = 90, by = 5)\nage_seq\n\n# Make labels for the above categories, assuming default cut() settings\nage_labels = paste0(age_seq+1, \"-\", age_seq + 5)\nage_labels\n\n# check that both vectors are the same length\nlength(age_seq) == length(age_labels)\n\n# # Use them in the cut() command\n# cut(linelist$age, breaks = age_seq, labels = age_labels)"},{"path":"cleaning-data.html","id":"case_when-1","chapter":"4 Cleaning data","heading":"4.10.3 case_when()","text":"dplyr function case_when() can also used create numeric categories.Allows explicit setting break point inclusion/exclusionAllows designation label NA values one stepMore complicated code, arguably prone errorAllow flexibility include variables logicIf using case_when() please review -depth page , logic order assignment important understand avoid errors.CAUTION: case_when() right-hand side values must class. Thus, categories character values (e.g. “20-30 years”) designated outcome NA age values must also character (“Missing”, special NA_character_ instead NA).need designate column factor (wrapping case_when() function factor()) provide ordering factor levels using levels = argument close case_when() function. using cut(), factor ordering levels done automatically.","code":"\nlinelist <- linelist %>% \n  mutate(age_cat = factor(case_when(\n          # provide the case_when logic and outcomes\n          age_years >= 0 & age_years < 5     ~ \"0-4\",          # logic by age_year value\n          age_years >= 5 & age_years < 10    ~ \"5-9\",\n          age_years >= 10 & age_years < 15   ~ \"10-14\",\n          age_years >= 15 & age_years < 20   ~ \"15-19\",\n          age_years >= 20 & age_years < 30   ~ \"20-29\",\n          age_years >= 30 & age_years < 50   ~ \"30-49\",\n          age_years >= 50 & age_years < 70   ~ \"50-69\",\n          age_years >= 45 & age_years <= 100 ~ \"70-100\",\n          is.na(age_years)                   ~ \"Missing\",  # if age_years is missing\n          TRUE                               ~ \"Check value\"   # catch-all alarm to trigger review\n          ), levels = c(\"0-4\",\"5-9\", \"10-14\", \"15-19\", \"20-29\", \"30-49\", \"50-69\", \"70-100\", \"Missing\", \"Check value\"))\n         )\n\n\ntable(linelist$age_cat, useNA = \"always\")## \r\n##         0-4         5-9       10-14       15-19       20-29       30-49 \r\n##        1078        1181         981         908        1089         665 \r\n##       50-69      70-100     Missing Check value        <NA> \r\n##          24           0          91           0           0"},{"path":"cleaning-data.html","id":"add-to-pipe-chain-3","chapter":"4 Cleaning data","heading":"4.10.4 Add to pipe chain","text":", code create two categorical age columns added cleaning pipe chain:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n  \n    # remove column\n        select(-c(row_num, merged_header, x25)) %>% \n\n    # fix incorrect values                 # old value       # new value\n    mutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\")) %>% \n    \n    # correct the class of the columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n  \n    \n    # create column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n\n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %>% \n    \n    filter(\n          # keep only rows where case_id is not missing\n          !is.na(case_id),  \n          \n          # also filter to keep only the second outbreak\n          date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\"))) %>% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################   \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))"},{"path":"cleaning-data.html","id":"rowwise-dplyr","chapter":"4 Cleaning data","heading":"4.11 rowwise() dplyr()","text":"https://cran.r-project.org/web/packages/dplyr/vignettes/rowwise.html","code":"\nlinelist <- linelist %>%\n  rowwise() %>%\n  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == \"yes\"))"},{"path":"cleaning-data.html","id":"transforming-multiple-variables-at-once","chapter":"4 Cleaning data","heading":"4.12 Transforming multiple variables at once","text":"CAUTION: tab may follow previous tabs.transformation can applied multiple variables using across() function package dplyr (contained within tidyverse package).across() can used dplyr verb, commonly mutate(), filter(), summarise(). examples get started.Example one change columns character classChange numeric columnsHere online resources using across(): Hadley Wickham’s thoughts/rationale","code":"\n#to change all columns to character class\nlinelist <- linelist %>% \n  mutate(across(everything(), as.character))"},{"path":"cleaning-data.html","id":"deduplication","chapter":"4 Cleaning data","heading":"4.13 Deduplication","text":"CAUTION: tab may follow previous tabs.package dplyr offers distinct() function reduce dataframe unique rows - removing duplicates.\r\ncase just want remove rows complete duplicates, just add simple command distinct().complex deduplications see page deduplicating.begin 6017 rows linelist.deduplication 5888 rows., distinct() command added cleaning pipe chain:","code":"\nlinelist <- linelist %>% \n  distinct()\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n  \n    # remove column\n        select(-c(row_num, merged_header, x25)) %>% \n\n    # fix incorrect values                 # old value       # new value\n    mutate(date_onset = recode(date_onset, \"15th April 2014\" = \"2014-04-15\")) %>% \n  \n    # correct the class of the columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # create column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n\n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %>% \n    \n    filter(\n          # keep only rows where case_id is not missing\n          !is.na(case_id),  \n          \n          # also filter to keep only the second outbreak\n          date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\"))) %>% \n  \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %>% \n  \n    distinct()"},{"path":"age-pyramids.html","id":"age-pyramids","chapter":"5 Age pyramids","heading":"5 Age pyramids","text":"Age pyramids can useful show patterns age group. can show gender, distribution characteristics.\r\ntabs demonstrate produce age pyramids using:Fast & easy: Using apyramid packageMore flexible: Using ggplot()baseline demographics displayed background pyramidUsing pyramid-style plots show types data (e.g responses Likert-style questions)","code":""},{"path":"age-pyramids.html","id":"overview-1","chapter":"5 Age pyramids","heading":"5.1 Overview","text":"Age/gender demographic pyramids R generally made ggplot() creating two barplots (one gender), converting one’s values negative values, flipping x y axes display barplots vertically.offer quick approach apyramid package:customizable code using raw ggplot() commandsHow combine case demographic data compare baseline population (shown )Application methods show types data (e.g. responses Likert-style survey questions)","code":""},{"path":"age-pyramids.html","id":"preparation-1","chapter":"5 Age pyramids","heading":"5.2 Preparation","text":"tab use linelist dataset cleaned Cleaning tab.make traditional age/sex demographic pyramid, data must first cleaned following ways:gender column must cleaned.Age age category column, class Factor (correctly ordered levels)Load packagesFirst, load packages required analysis:Load dataCheck class variablesEnsure age variable class Numeric, check class order levels age_cat age_cat5","code":"\npacman::p_load(rio,       # to import data\n               here,      # to locate files\n               tidyverse, # to clean, handle, and plot the data (includes ggplot2 package)\n               apyramid,  # a package dedicated to creating age pyramids\n               stringr)   # working with strings for titles, captions, etc.\nlinelist <- rio::import(\"linelist_cleaned.csv\")\nclass(linelist$age_years)## [1] \"numeric\"\nclass(linelist$age_cat)## [1] \"factor\"\nclass(linelist$age_cat5)## [1] \"factor\"\ntable(linelist$age_cat, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-29 30-49 50-69   70+  <NA> \r\n##  1054  1153   957   889  1065   658    24     0    88\ntable(linelist$age_cat5, useNA = \"always\")## \r\n##   0-4   5-9 10-14 15-19 20-24 25-29 30-34 35-39 40-44 45-49 50-54 55-59 60-64 \r\n##  1054  1153   957   889   570   495   315   171   113    59    14     6     2 \r\n## 65-69 70-74 75-79 80-84   85+  <NA> \r\n##     2     0     0     0     0    88"},{"path":"age-pyramids.html","id":"apyramid-package","chapter":"5 Age pyramids","heading":"5.3 apyramid package","text":"package apyramid allows quickly make age pyramid. nuanced situations, see tab using ggplot() make age pyramids. can read apyramid package Help page entering ?age_pyramid R console.","code":""},{"path":"age-pyramids.html","id":"linelist-data","chapter":"5 Age pyramids","heading":"5.3.1 Linelist data","text":"Using cleaned linelist dataset, can create age pyramid just one simple command. need help cleaning data, see handbook page Cleaning data (LINK). command:data argument set linelist dataframeThe age_group argument set name (quotes) numeric category variable (case age_cat5)split_by argument (bar colors) binary column (case “gender”)\r\nusing agepyramid package, split_by column binary (e.g. male/female, yes/), result appear pyramid. However two values split_by column (including NA), pyramid appears faceted barplot empty bars background indicating range un-faceted data set age group. Values split_by appear labels top facet. example split_by variable “hospital”.Missing values\r\nRows missing values split_by age_group columns, coded NA, trigger faceting shown . default rows shown. However can specify appear, adjacent barplot separate age group top, specifying na.rm = FALSE.Proportions, colors, & aestheticsBy default, bars display counts (%), dashed mid-line group shown, colors green/purple. parameters can adjusted, shown :can also add additional ggplot() commands plot using standard ggplot() “+” syntax, aesthetic themes label adjustments:","code":"\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\")## Warning: 281 missing rows were removed (88 values from `age_cat5` and 281 values\r\n## from `gender`).\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"hospital\",\n                      na.rm = FALSE)        # show a bar for patients missing age, (note: this changes the pyramid into a faceted barplot)\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      na.rm = FALSE)         # show patients missing age or gender\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      proportional = TRUE,                  # show percents, not counts\n                      show_midpoint = FALSE,                # remove bar mid-point line\n                      #pal = c(\"orange\", \"purple\")          # can specify alt. colors here (but not labels, see below)\n                      )+                 \n  \n  # additional ggplot commands\n  theme_minimal()+                                          # simplify the background\n  scale_fill_manual(values = c(\"orange\", \"purple\"),         # to specify colors AND labels\n                     labels = c(\"Male\", \"Female\"))+\n  labs(y = \"Percent of all cases\",                          # note that x and y labels are switched (see ggplot tab)\n       x = \"Age categories\",                          \n       fill = \"Gender\", \n       caption = \"My data source and caption here\",\n       title = \"Title of my plot\",\n       subtitle = \"Subtitle with \\n a second line...\")+\n  theme(\n    legend.position = \"bottom\",                             # move legend to bottom\n    axis.text = element_text(size = 10, face = \"bold\"),     # fonts/sizes, see ggplot tips page\n    axis.title = element_text(size = 12, face = \"bold\"))## Warning: 281 missing rows were removed (88 values from `age_cat5` and 281 values\r\n## from `gender`).## Scale for 'fill' is already present. Adding another scale for 'fill', which\r\n## will replace the existing scale."},{"path":"age-pyramids.html","id":"aggregated-data","chapter":"5 Age pyramids","heading":"5.3.2 Aggregated data","text":"examples assume data linelist-like format, one row per observation. data already aggregated counts age category, can still use apyramid package, shown .Let’s say dataset looks like , columns age category, male counts, female counts, missing counts.\r\n(see handbook page Transforming data tips)ggplot() perfers data “long” format, first pivot data “long” pivot_longer() function dplyr.use split_by count arguments age_pyramid() specify respective columns:Note , factor order “m” “f” different (pyramid reversed). adjust order must re-define gender aggredated data Factor order levels desired.","code":"## `summarise()` has grouped output by 'age_cat5'. You can override using the `.groups` argument.\n# View the aggregated data\nDT::datatable(demo_agg, rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T) )\n# pivot the aggregated data into long format\ndemo_agg_long <- demo_agg %>% \n  pivot_longer(c(f, m, missing_gender),            # cols to elongate\n               names_to = \"gender\",                # name for new col of categories\n               values_to = \"counts\") %>%           # name for new col of counts\n  mutate(gender = na_if(gender, \"missing_gender\")) # convert \"missing_gender\" to NA\n# View the aggregated data\nDT::datatable(demo_agg_long, rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T) )\napyramid::age_pyramid(data = demo_agg_long,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      count = \"counts\")      # give the column name for the aggregated counts## Warning: Removed 20 rows containing missing values (position_stack).## Warning: Removed 19 rows containing missing values."},{"path":"age-pyramids.html","id":"ggplot","chapter":"5 Age pyramids","heading":"5.4 ggplot()","text":"Using ggplot() build age pyramid allows flexibility, requires effort understanding ggplot() works. also easier accidentally make mistakes.apyramid uses ggplot() background (accepts ggplot() commands added), page shows adjust recreate pyramid using ggplot(), wish.","code":""},{"path":"age-pyramids.html","id":"constructing-the-plot","chapter":"5 Age pyramids","heading":"5.4.1 Constructing the plot","text":"First, understand make pyramid using ggplot() approach :Within ggplot(), create two graphs age category. Create one two grouping values (case gender). See filters applied data arguments geom_histogram() commands .Within ggplot(), create two graphs age category. Create one two grouping values (case gender). See filters applied data arguments geom_histogram() commands .using geom_histogram(), graphs operate numeric column (e.g. age_years), whereas using geom_barplot() graphs operate ordered Factor (e.g. age_cat5).using geom_histogram(), graphs operate numeric column (e.g. age_years), whereas using geom_barplot() graphs operate ordered Factor (e.g. age_cat5).One graph positive count values, counts converted negative values - allows graphs seen compared plot.One graph positive count values, counts converted negative values - allows graphs seen compared plot.command coord_flip() switches X Y axes, resulting graphs turning vertical creating pyramid.command coord_flip() switches X Y axes, resulting graphs turning vertical creating pyramid.Lastly, counts-axis labels must specified appear “positive” counts sides pyramid (despite underlying values one side negative).Lastly, counts-axis labels must specified appear “positive” counts sides pyramid (despite underlying values one side negative).simple version , using geom_histogram(), :DANGER: limits counts axis set low, counts bar exceeds , bar disappear entirely artificially shortened! Watch analyzing data routinely updated. Prevent count-axis limits auto-adjust data, .many things can change/add simple version, including:Auto adjust counts-axis count scale data (avoid errors discussed warning )Manually specify colors legend labels","code":"\n  # begin ggplot\n  ggplot(data = linelist, aes(x = age, fill = gender)) +\n  \n  # female histogram\n  geom_histogram(data = filter(linelist, gender == \"f\"),\n                 breaks = seq(0,85,5),\n                 colour = \"white\") +\n  \n  # male histogram (values converted to negative)\n  geom_histogram(data = filter(linelist, gender == \"m\"),\n                 breaks = seq(0,85,5),\n                 aes(y=..count..*(-1)),\n                 colour = \"white\") +\n  \n  # flip the X and Y axes\n  coord_flip() +\n  \n  # adjust counts-axis scale\n  scale_y_continuous(limits = c(-600, 900),\n                     breaks = seq(-600,900,100),\n                     labels = abs(seq(-600, 900, 100)))\n# create dataset with proportion of total\npyramid_data <- linelist %>%\n  group_by(age_cat5, gender) %>% \n  summarize(counts = n()) %>% \n  ungroup() %>% \n  mutate(percent = round(100*(counts / sum(counts, na.rm=T)),1), \n         percent = case_when(\n            gender == \"f\" ~ percent,\n            gender == \"m\" ~ -percent,\n            TRUE          ~ NA_real_))## `summarise()` has grouped output by 'age_cat5'. You can override using the `.groups` argument.\nmax_per <- max(pyramid_data$percent, na.rm=T)\nmin_per <- min(pyramid_data$percent, na.rm=T)\n\n\n# begin ggplot\n  ggplot()+  # default x-axis is age in years;\n\n  # case data graph\n  geom_bar(data = pyramid_data,\n           stat = \"identity\",\n           aes(x = age_cat5,\n               y = percent,\n               fill = gender),        # \n           colour = \"white\")+         # white around each bar\n  \n  # flip the X and Y axes to make pyramid vertical\n  coord_flip()+\n  \n\n  # adjust the axes scales (remember they are flipped now!)\n  #scale_x_continuous(breaks = seq(0,100,5), labels = seq(0,100,5)) +\n  scale_y_continuous(limits = c(min_per, max_per),\n                     breaks = seq(floor(min_per), ceiling(max_per), 2),\n                     labels = paste0(abs(seq(floor(min_per), ceiling(max_per), 2)), \"%\"))+\n\n  # designate colors and legend labels manually\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",\n               \"m\" = \"darkgreen\"),\n    labels = c(\"Female\", \"Male\"),\n  ) +\n  \n  # label values (remember X and Y flipped now)\n  labs(\n    x = \"Age group\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Data are from linelist \\nn = {nrow(linelist)} (age or sex missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases) \\nData as of: {format(Sys.Date(), '%d %b %Y')}\")) +\n  \n  # optional aesthetic themes\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0.5), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\")) + \n  \n  ggtitle(paste0(\"Age and gender of cases\"))## Warning: Removed 10 rows containing missing values (position_stack)."},{"path":"age-pyramids.html","id":"compare-to-baseline","chapter":"5 Age pyramids","heading":"5.4.2 Compare to baseline","text":"flexibility ggplot(), can second layer bars background represent true population pyramid. can provide nice visualization compare observed counts baseline.Import view population dataFirst data management steps:record order age categories want appear. Due quirks way ggplot() implemented, easiest store character vector use later plotting function.Combine population case data dplyr function bind_rows():First, ensure exact column names, age categories values, gender valuesMake data structure: columns age category, gender, counts, percent totalBind together, one -top (bind_rows())Review changed population datasetNow implement case linelist. Slightly different begins case-rows, counts.Review changed case datasetNow two datasets combined, one top (column names)Store maximum minimum percent values, used plotting funtion define extent plot (cut bars!)Now plot made ggplot():One bar graph population data (wider, transparent bars)One bar graph case data (small, solid bars)","code":"\n# import the population demographics data\npop <- rio::import(\"country_demographics.csv\")\n# display the linelist data as a table\nDT::datatable(pop, rownames = FALSE, filter=\"top\", options = list(pageLength = 10, scrollX=T) )\n# record correct age cat levels\nage_levels <- c(\"0-4\",\"5-9\", \"10-14\", \"15-19\", \"20-24\",\n                \"25-29\",\"30-34\", \"35-39\", \"40-44\", \"45-49\",\n                \"50-54\", \"55-59\", \"60-64\", \"65-69\", \"70-74\",\n                \"75-79\", \"80-84\", \"85+\")\n# create/transform populaton data, with percent of total\n########################################################\npop_data <- pivot_longer(pop, c(m, f), names_to = \"gender\", values_to = \"counts\") %>% # pivot gender columns longer\n  mutate(data = \"population\",                                                         # add column designating data source\n         percent  = round(100*(counts / sum(counts, na.rm=T)),1),                     # calculate % of total\n         percent  = case_when(                                                        # if male, convert % to negative\n                            gender == \"f\" ~ percent,\n                            gender == \"m\" ~ -percent,\n                            TRUE          ~ NA_real_))\n# display the linelist data as a table\nDT::datatable(pop_data, rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T) )\n# create case data by age/gender, with percent of total\n#######################################################\ncase_data <- linelist %>%\n  group_by(age_cat5, gender) %>%  # aggregate linelist cases into age-gender groups\n  summarize(counts = n()) %>%     # calculate counts per age-gender group\n  ungroup() %>% \n  mutate(data = \"cases\",                                          # add column designating data source\n         percent = round(100*(counts / sum(counts, na.rm=T)),1),  # calculate % of total for age-gender groups\n         percent = case_when(                                     # convert % to negative if male\n            gender == \"f\" ~ percent,\n            gender == \"m\" ~ -percent,\n            TRUE          ~ NA_real_))## `summarise()` has grouped output by 'age_cat5'. You can override using the `.groups` argument.\n# display the linelist data as a table\nDT::datatable(case_data, rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T) )\n# combine case and population data (same column names, age_cat values, and gender values)\npyramid_data <- bind_rows(case_data, pop_data)\n# Define extent of percent axis, used for plot limits\nmax_per <- max(pyramid_data$percent, na.rm=T)\nmin_per <- min(pyramid_data$percent, na.rm=T)\n# begin ggplot\n##############\nggplot()+  # default x-axis is age in years;\n\n  # population data graph\n  geom_bar(data = filter(pyramid_data, data == \"population\"),\n           stat = \"identity\",\n           aes(x = age_cat5,\n               y = percent,\n               fill = gender),        \n           colour = \"black\",                               # black color around bars\n           alpha = 0.2,                                    # more transparent\n           width = 1)+                                     # full width\n  \n  # case data graph\n  geom_bar(data = filter(pyramid_data, data == \"cases\"), \n           stat = \"identity\",                              # use % as given in data, not counting rows\n           aes(x = age_cat5,                               # age categories as original X axis\n               y = percent,                                # % as original Y-axis\n               fill = gender),                             # fill of bars by gender\n           colour = \"black\",                               # black color around bars\n           alpha = 1,                                      # not transparent \n           width = 0.3)+                                   # half width\n  \n  # flip the X and Y axes to make pyramid vertical\n  coord_flip()+\n  \n  # adjust axes order, scale, and labels (remember X and Y axes are flipped now)\n  # manually ensure that age-axis is ordered correctly\n  scale_x_discrete(limits = age_levels)+ \n  \n  # set percent-axis \n  scale_y_continuous(limits = c(min_per, max_per),                                          # min and max defined above\n                     breaks = seq(floor(min_per), ceiling(max_per), by = 2),                # from min% to max% by 2 \n                     labels = paste0(                                                       # for the labels, paste together... \n                       abs(seq(floor(min_per), ceiling(max_per), by = 2)),                  # ...rounded absolute values of breaks... \n                       \"%\"))+                                                               # ... with \"%\"\n                                                                                            # floor(), ceiling() round down and up \n\n  # designate colors and legend labels manually\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",         # assign colors to values in the data\n               \"m\" = \"darkgreen\"),\n    labels = c(\"f\" = \"Female\",\n               \"m\"= \"Male\"),      # change labels that appear in legend, note order\n  ) +\n\n  # plot labels, titles, caption    \n  labs(\n    title = \"Case age and gender distribution,\\nas compared to baseline population\",\n    subtitle = \"\",\n    x = \"Age category\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Cases shown on top of country demographic baseline\\nCase data are from linelist, n = {nrow(linelist)}\\nAge or gender missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases\\nCase data as of: {format(max(linelist$date_onset, na.rm=T), '%d %b %Y')}\")) +\n  \n  # optional aesthetic themes\n  theme(\n    legend.position = \"bottom\",                             # move legend to bottom\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\"))## Warning: Removed 10 rows containing missing values (position_stack)."},{"path":"age-pyramids.html","id":"likert-scale","chapter":"5 Age pyramids","heading":"5.5 Likert scale","text":"techniques used make population pyramid ggplot() can also used make plots Likert-scale survey data.Import dataStart data looks like , categorical classification respondent (status) answers 8 questions 4-point Likert-type scale (“poor”, “Poor”, “Good”, “good”).First, data management steps:Pivot data longerCreate new column direction depending whether response generally “positive” “negative”Set Factor level order status column Response columnStore max count value limits plot appropriateNow make plot:","code":"\n# import the likert survey response data\nlikert_data <- rio::import(\"likert_data.csv\")\n# display the linelist data as a table\nDT::datatable(likert_data, rownames = FALSE, filter=\"top\", options = list(pageLength = 10, scrollX=T) )\nmelted <- pivot_longer(likert_data, Q1:Q8, names_to = \"Question\", values_to = \"Response\") %>% \n     mutate(direction = case_when(\n               Response %in% c(\"Poor\",\"Very Poor\") ~ \"Negative\",\n               Response %in% c(\"Good\", \"Very Good\") ~ \"Positive\",\n               TRUE ~ \"Unknown\"),\n            status = factor(status, levels = rev(c(\n                 \"Senior\", \"Intermediate\", \"Junior\"))),\n            Response = factor(Response, levels = c(\"Very Good\", \"Good\",\n                                             \"Very Poor\", \"Poor\"))) # must reverse Very Poor and Poor for ordering to work\n\nmelted_max <- melted %>% \n   group_by(status, Question) %>% \n   summarize(n = n())## `summarise()` has grouped output by 'status'. You can override using the `.groups` argument.\nmelted_max <- max(melted_max$n, na.rm=T)\n# make plot\nggplot()+\n     # bar graph of the \"negative\" responses \n     geom_bar(data = filter(melted,\n                            direction == \"Negative\"), \n              aes(x = status,\n                        y=..count..*(-1),    # counts inverted to negative\n                        fill = Response),\n                    color = \"black\",\n                    closed = \"left\", \n                    position = \"stack\")+\n     \n     # bar graph of the \"positive responses\n     geom_bar(data = filter(melted, direction == \"Positive\"),\n              aes(x = status, fill = Response),\n              colour = \"black\",\n              closed = \"left\",\n              position = \"stack\")+\n     \n     # flip the X and Y axes\n     coord_flip()+\n  \n     # Black vertical line at 0\n     geom_hline(yintercept = 0, color = \"black\", size=1)+\n     \n    # convert labels to all positive numbers\n    scale_y_continuous(limits = c(-ceiling(melted_max/10)*11, ceiling(melted_max/10)*10),   # seq from neg to pos by 10, edges rounded outward to nearest 5\n                       breaks = seq(-ceiling(melted_max/10)*10, ceiling(melted_max/10)*10, 10),\n                       labels = abs(unique(c(seq(-ceiling(melted_max/10)*10, 0, 10),\n                                            seq(0, ceiling(melted_max/10)*10, 10))))) +\n     \n    # color scales manually assigned \n    scale_fill_manual(values = c(\"Very Good\"  = \"green4\", # assigns colors\n                                  \"Good\"      = \"green3\",\n                                  \"Poor\"      = \"yellow\",\n                                  \"Very Poor\" = \"red3\"),\n                       breaks = c(\"Very Good\", \"Good\", \"Poor\", \"Very Poor\"))+ # orders the legend\n     \n    \n     \n    # facet the entire plot so each question is a sub-plot\n    facet_wrap(~Question, ncol = 3)+\n     \n    # labels, titles, caption\n    labs(x = \"Respondent status\",\n          y = \"Number of responses\",\n          fill = \"\")+\n     ggtitle(str_glue(\"Likert-style responses\\nn = {nrow(likert_data)}\"))+\n\n     # aesthetic settings\n     theme_minimal()+\n     theme(axis.text = element_text(size = 12),\n           axis.title = element_text(size = 14, face = \"bold\"),\n           strip.text = element_text(size = 14, face = \"bold\"),  # facet sub-titles\n           plot.title = element_text(size = 20, face = \"bold\"),\n           panel.background = element_rect(fill = NA, color = \"black\")) # black box around each facet## Warning: Ignoring unknown parameters: closed\r\n\r\n## Warning: Ignoring unknown parameters: closed"},{"path":"age-pyramids.html","id":"resources","chapter":"5 Age pyramids","heading":"5.6 Resources","text":"tab stay name “Resources”.\r\nLinks online tutorials resources.","code":""}]
