
# Joining & matching datasets {.tabset .tabset-fade}  


<!-- ======================================================= -->
## Overview {.tabset .tabset-fadehosp_info}


```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
```

This page describes common "joins" and also probabilistic matching between dataframes.  


<!-- ======================================================= -->
## Preparation {.tabset .tabset-fade}

**Load packages**

```{r}
pacman::p_load(
  rio,            # import/export
  here,           # relative filepaths
  tidyverse,      # data management/viz
  RecordLinkage,  # probabilistic matches
  fastLink        # probabilistic matches
)
```
Because traditional joins (non-probabilistic) can be very specific, requiring exact string matches, you may need to do cleaning on the datasets *prior to* the join (e.g. change spellings, change case to all lower or upper).  


**Load data**  


Load the data  

```{r, echo=F}
linelist <- rio::import(here("data", "linelist_cleaned.rds"))
```

```{r, eval=F}
linelist <- rio::import("linelist_cleaned.csv")
```

<!-- ======================================================= -->
### Datasets {.tabset .tabset-fade}
In the joining examples, we'll use the following datasets:  

1) A "miniature" version of the `linelist`, containing only the columns `case_id`, `date_onset`, and `hospital`, and only the first 10 rows  
2) A separate dataframe named `hosp_info`, which contains more details about each hospital  


**"miniature" linelist**  

Below is the miniature linelist used for demonstration purposes:  

```{r}
linelist_mini <- linelist %>%                 # start with original linelist
  select(case_id, date_onset, hospital) %>%   # select columns
  head(10)                                    # keep only the first 10 rows
```

```{r message=FALSE, echo=F}
DT::datatable(linelist_mini, rownames = FALSE, options = list(pageLength = nrow(linelist_mini)))
```

**Hospital Information dataframe**  

Below is the separate dataframe with additional information about each hospital.  

```{r, echo = F}
hosp_info = data.frame(
  hosp_name     = c("central hospital", "military", "military", "port", "St. Mark's", "ignace", "sisters"),
  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),
  level  = c("Tertiary", "Secondary", "Primary", "Secondary", "Secondary", "Primary", "Primary")
)
```

```{r message=FALSE, echo=F}
# display the hospital data as a table
DT::datatable(hosp_info, rownames = FALSE, options = list(pageLength = nrow(hosp_info)))
```





<!-- ======================================================= -->
### Pre-cleaning {.tabset .tabset-fade}

Because traditional (non-probabilistic) joins are case-sensitive and require exact string matches, we will clean-up the `hosp_info` dataset prior to the joins.  

**Identify differences**  

We need the values of `hosp_name` column in `hosp_info` dataframe to match the values of `hospital` column in the `linelist` dataframe.  

Here are the values in `linelist_mini`:  

```{r}
unique(linelist_mini$hospital)
```

and here are the values in `hosp_info`:  

```{r}
unique(hosp_info$hosp_name)
```



**Align matching values**  

We begin by cleaning the values in `hosp_name`. We use logic to code the values in the new column using `case_when()` (LINK). We correct the hospital names that exist in both dataframes, and leave the others as they are (see `TRUE ~ hosp_name`).   

<span style="color: orange;">**_CAUTION:_** Typically, one should create a new column (e.g. `hosp_name_clean`), but for ease of demonstration we show modification of the old column</span>

```{r}
hosp_info <- hosp_info %>% 
  mutate(
    hosp_name = case_when(
      hosp_name == "military"          ~ "Military Hospital",
      hosp_name == "port"              ~ "Port Hospital",
      hosp_name == "St. Mark's"        ~ "St. Mark's Maternity Hospital (SMMH)",
      hosp_name == "central hospital"  ~ "Central Hospital",
      TRUE                             ~ hosp_name
      )
    )
```

We now see that the hospital names that appear in both dataframe are aligned. There are some hospitals in `hosp_info` that are not present in `linelist` - we will deal with these later, in the join.  

```{r}
unique(hosp_info$hosp_name)
```

If you need to convert to all values UPPER or lower case, use these functions from **stringr**, as shown in the page on characters/strings (LINK).  

`str_to_upper()`  
`str_to_upper()`  
`str_to_title()`  




<!-- ======================================================= -->
## **dplyr** joins {.tabset .tabset-fade}

**dplyr** offers several different joins. Below they are described, with some simple use cases. Many thanks to [https://github.com/gadenbuie](https://github.com/gadenbuie/tidyexplain/tree/master/images) for the moving images!  




<!-- ======================================================= -->
### General syntax {.tabset .tabset-fade}


**General function structure**  

Any of these join commands can be run independently, like below.  

An object is being created, or re-defined: dataframe 2 is being joined to dataframe 1, on the basis of matches between the "ID" column in `df1` and "identifier" column in `df2`. Because this example uses `left_join()`, any rows in `df2` that do not match to `df1` will be dropped.     

```{r, eval=F}
object <- left_join(df1, df2, by = c("ID" = "identifier"))
```

The join commands can also be run within a pipe chain. The first dataframe `df1` is known to be the dataframe that is being passed through the pipes. An example is shown below, in context with some additional non-important `mutate()` and `filter()` commands before the join.  

```{r eval=F}
object <- df1 %>%
  filter(var1 == 2) %>%        # for demonstration only
  mutate(lag = day + 7) %>%    # for demonstration only
  left_join(df1, by = c("ID" = "identifier"))  # join df2 to df1
```

**Join columns (`by = `)**  

You must specify the columns in each dataset in which the values must match, using the arguemnt `by = `. You have a few options:  

* Specify only one column name (`by = "ID"`) - this only works if this exact column name is present in both dataframes!  
* Specify the different names (`by = c("ID" = "Identifier")` - use this if the column names are different in the 2 dataframes  
* Specify multiple columns to match on (`by = c("ID" = "Identifier", "date_onset" = "Date_of_Onset")`) - this will require exact matches on multiple columns for rows to join.  


<span style="color: orange;">**_CAUTION:_** Joins are case-specific! Therefore it is useful to convert all values to lowercase or uppercase prior to joining. See the page on characters/strings.</span>



### 



<!-- ======================================================= -->
### Add columns: left & right joins  

**A left or right join is commonly used to add information to a dataframe** - new information is added only to rows that already exist in the baseline dataframe.  

These are common joins in epidemiological work - they are used to add information from one dataset into another. 

*The order of the dataframes is important*.  

* In a *left join*, the *first* (left) dataframe listed is the baseline  
* In a *right join*, the *second* (right) dataframe listed is the baseline  

**All rows of the baseline dataframe are kept.** Information in the secondary dataframe is joined to the baseline dataframe *only if there is a match via the identifier column(s)*. In addition:  
* Rows in the secondary dataframe that do not match are dropped.  
* If there are many baseline rows that match to one row in the secondary dataframe (many-to-one), the baseline information is added to each matching baseline row.  
* If a baseline row matches to multiple rows in the secondary dataframe (one-to-many), all combinations are given, meaning new rows may be added to your returned dataframe!  

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
knitr::include_graphics(here::here("images", "right-join.gif"))
```

**Example**  

Below is the output of a `left_join()` of `hosp_info` (secondary dataframe)  *into* `linelist_mini` (baseline dataframe). Note the following:  

* All original rows of the baseline dataframe `linelist_mini` are kept  
* One original row of `linelist_mini` is duplicated ("Military Hospital") because it matched to *two* rows in the secondary dataframe, so both combinations are returned  
* The join identifier column of the secondary dataset (`hosp_name`) has disappeared because it is redundant with the identifier column in the primary dataset (`hospital`)  
* When a baseline row did not match to any secondary row (e.g. when `hospital` is "Other" or "Missing"), `NA` fills in the columns from the secondary dataframe  
* Rows in the secondary dataframe with no match to the baseline dataframe ("sisters" and "ignace") were dropped  


```{r, eval=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```




**"Should I use a right join, or a left join?"**  
Most important is to ask "which dataframe should retain all of its rows?" - use this one as the baseline.

The two commands below achieve the same output - 10 rows of `hosp_info` joined *into* a `linelist_mini` baseline. However, the column order will differ based on whether `hosp_info` arrives from the right (in the left join) or arrives from the left (in the right join). The order of the rows may also shift consequently.   

Also consider whether your use-case is within a pipe chain (`%>%`). If the dataset in the pipes is the baseline, you will likely use a left join to add data to it.  

```{r, eval=F}
# The two commands below achieve the same data, but with differently ordered rows and columns
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name"))
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital"))
```

```{r message=FALSE, echo=F}
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

```{r message=FALSE, echo=F}
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```




<!-- ======================================================= -->
### Full join  

**A full join is the most *inclusive* of the joins** - it returns all rows from both dataframes.  

If there are any rows present in one and not the other (where no match was found), the dataframe will become wider as `NA` values are added to fill-in. Watch the number of columns and rows carefully and troubleshoot case-sensitivity and exact string matches. 

Adjustment of the "baseline" (first) dataframe will not impact which records are returned, but it will impact the column order, row order, and which identifier column is retained.  

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "full-join.gif"))
```


**Example**  

Below is the output of a `full_join()` of `hosp_info`  *into* `linelist_mini`. Note the following:  

* All baseline rows (`linelist_mini`) are kept  
* One baseline row is duplicated ("Military Hospital") because it matched to two secondary rows and both combinations are returned  
* Only the identifier column from the baseline is kept (`hospital`)  
* `NA` fills in where baseline rows did not match to secondary rows (`hospital` was "Other" or "Missing"), or the opposite (where `hosp_name` was "ignace" or "sisters")  


```{r, eval=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 13))
```





<!-- ======================================================= -->
### Inner join  

**An inner join is the most *restrictive* of the joins** - it returns only rows with matches across both dataframes.  
This means that your original dataset may reduce in number of rows. Adjustment of the "baseline" (first) dataframe will not impact which records are returned, but it will impact the column order, row order, and which identifier column is retained.   


```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "inner-join.gif"))
```


**Example**  

Below is the output of an `inner_join()` of `linelist_mini` (baseline) with `hosp_info` (secondary). Note the following:  

* Not all baseline rows are kept (rows where `hospital` is "Missing" or "Other" are removed because had no match in the secondary dataframe  
* Likewise, secondary rows where `hosp_name` is "sisters" or "ignace" are removed as they have no match in the baseline dataframe  
* Only the identifier column from the baseline is kept (`hospital`)  


```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```


```{r, eval=F}
hosp_info %>% 
  inner_join(linelist_mini, by = c("hosp_name" = "hospital"))
```


```{r message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```






<!-- ======================================================= -->
### Semi join  

A semi join is a "filtering join" which uses another dataset *not to add rows or columns, but to perform filtering*.  
A **semi-join keeps all observations in dataframe 1 that have a match in dataframe 2** (but does not add new columns or duplicate any rows with multiple matches). Read more about filtering joins [here](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0).  

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "semi-join.gif"))
```

The below code would return **0** rows, because the two dataframes are completely different - there are no rows that are in both.  

```{r, eval=F}
hosp_info %>% 
  semi_join(linelist_mini, by = c("hosp_name" = "hospital"))
```



<!-- ======================================================= -->
### Anti join  

**The anti join is a "filtering join" that returns rows in dataframe 1 that *do not* have a match in dataframe 2.**  

Read more about filtering joins [here](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0).  

Common scenarios for an anti-join include identifying records not present in another dataframe, troubleshooting spelling in a join (catching records that *should have* matched), and examining records that were excluded after another join.  

**As with right_join() and left_join(), the *baseline* dataframe (listed first) is important**. The returned rows are from it only. Notice in the gif below that row in the non-baseline dataframe (purple 4) is not returned even though it does not match.  

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "anti-join.gif"))
```

**Simple example**  

For an example, let's find the `hosp_info` hospitals that do not have any cases present in `linelist_mini`. We list `hosp_info` first, as the baseline dataframe. The two hospitals which are not present in `linelist_mini` are returned.  

```{r, eval=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital"))
```

```{r message=FALSE, echo=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```


**Example 2**  

For another example, let us say we ran an `inner_join()` between `linelist_mini` and `hosp_info`. This returns only 8 of the original 11 `linelist_mini` records.  

```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 8))
```

To review the 3 `linelist_mini` records that were excluded in the inner join, we can run an anti-join with `linelist_mini` as the baseline dataframe.  

```{r, eval = F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 5))
```

To see the `hosp_info` records that were excluded in the inner join, we could also run an anti-join with `hosp_info` as the baseline dataframe.  






<!-- ======================================================= -->
## Probabalistic matching {.tabset .tabset-fade}

Under construction - TBD

If you do not have a unique identifier common across datasets to join on, consider using a probabilistic matching algorithm. This would find matches between records based on similarity (e.g. Jaroâ€“Winkler string distance, or numeric distance).  Below is a simple example using the package **fastLink** .  

**Load packages**  

```{r}
pacman::p_load(
               tidyverse,      # data manipulation and visualization
               fastLink        # record matching
               )
```



```{r, echo=F}
# make datasets

cases <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural"
)

results <- tribble(
  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,
  "M",      "Amir",     NA,          "Khan",         1989, 11,   22,  "River", "positive",
  "M",      "Tony",   "B",         "Smith",          1970, 09,   19,  "River", "positive",
  "F",      "Maria",    "Contreras", "Rodriguez",    1972, 04,   15,  "Cty",   "negative",
  "F",      "Betty",    "Castel",   "Chase",        1954,  03,   30,  "City",  "positive",
  "F",      "Andrea",   NA,          "Kumaraswamy",  2001, 01,   05,  "Rural", "positive",      
  "F",      "Caroline", NA,          "Wang",         1988, 12,   11,  "Rural", "negative",
  "F",      "Trang",    NA,          "Nguyen",       1981, 06,   10,  "Rural", "positive",
  "M",      "Olivier" , "Laurent",   "De Bordeaux",  NA,   NA,   NA,  "River", "positive",
  "M",      "Mike",     "Murphy",    "O'Callaghan",  1969, 04,   12,  "Rural", "negative",
  "F",      "Cassidy",  "Jones",     "Davis",        1980, 07,   02,  "City",  "positive",
  "M",      "Mohammad", NA,          "Ali",          1942, 01,   17,  "City",  "negative",
  NA,       "Jose",     "Sanchez",   "Lopez",        1995, 01,   06,  "City",  "negative",
  "M",      "Abubakar", NA,          "Abullahi",     1960, 01,   01,  "River", "positive",
  "F",      "Maria",    "Salinas",   "Contreras",    1955, 03,   03,  "River", "positive"
  )

```

Here are two small example datasets that we will use to demonstrate the probabilistic matching:  

**The `cases` dataset has 9 records** of patients who are awaiting test results.  

```{r message=FALSE, echo=F}
# display the hospital data as a table
DT::datatable(cases, rownames = FALSE, options = list(pageLength = nrow(cases), scrollX=T))
```



**The `test_results` dataset** has 14 records and contains the column `result`, which we want to add to the records in `cases` based on probabilistic matching of records.  

```{r message=FALSE, echo=F}
# display the hospital data as a table
DT::datatable(results, rownames = FALSE, options = list(pageLength = nrow(results), scrollX=T))
```

### Probabilistic matching  

The `fastLink()` function from the **fastLink** package can be used to apply a matching algorithm. Here is the basic informaton. You can read more detail by entering `?fastLink` in your console.  

* Define the two dataframes for comparison as `dfA = ` and `dfB = `  
* In `varnames = ` give all column names to be used for matching. They must all exist in both `dfA` and `dfB`.  
* In `stringdist.match = ` give columns from those in `varnames` to be evaluated on string "distance".  
* In `numeric.match = ` give columns from those in `varnames` to be evaluated on numeric distance.  
* Missing values are ignored  
* By default, each row in either dataframe is matched to at most one row in the other dataframe. If you want to see all the evaluated matches, set `dedupe.matches = FALSE`. The deduplication is done using Winkler's linear assignment solution.  

*Tip: split one date column into three separate numeric columns using `day()`, `month()`, and `year()` from **lubridate** package*  

The default threshold for matches is 0.94 (`threshold.match = `) but you can adjust it higher or lower. If you define the threshold, consider that higher thresholds could yield more false-negatives (rows that do not match which actually should match) and likewise a lower threshold could yield more false-positive matches.  

Below, the data are matched on string distance across the name and district columns, and on numeric distance for year, month, and day of birth. A match threshold of 95% probability is set.  


```{r, message=F, warning=F}
fl_output <- fastLink::fastLink(
  dfA = cases,
  dfB = results,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district"),
  stringdist.match = c("first", "middle", "last", "district"),
  numeric.match = c("yr", "mon", "day"),
  threshold.match = 0.95)
```

**Review matches**  

We defined the object returned from `fastLink()` as `fl_output`. It is of class `list`, and it actually contains several dataframes within it, detailing the results of the matching. One of these dataframes is `matches`, which contains the most likely matches across `cases` and `results`. You can access this "matches" dataframe with `fl_output$matches`. Below, it is saved as `my_matches` for ease of accessing later.    

When `my_matches` is printed, you see two column vectors: the pairs of row numbers/indices (also called "rownames") in `cases` ("inds.a") and in `results` ("inds.b") representing the best matches. If a row number from a datafrane is missing, then no match was found in the other at the specified match threshold.    

```{r}
# print matches
my_matches <- fl_output$matches
my_matches
```

Things to note:  

* Matches occurred despite slight differences in name spelling and dates of birth:  
  * "Tony" matched to "Anthony"  
  * "Maria" matched to "Marialisa"  
  * "Betty" matched to "Elizabeth"  
  * "Olivier Laurent De Bordeaux" matched to "Oliver Laurent De Bordow" (missing date of birth ignored)  
* One row from `cases` (for "Blessing Adebayo", row 9) had no good match in `results`, so it is not present in `my_matches`.  




**Join based on the probabilistic matches**  

To use these matches to join `results` to `cases`, one strategy is:  

1) Use `left_join()` to join `my_matches` to `cases` (matching rownames in `cases` to "inds.a" in `my_matches`)  
2) Then use another `left_join()` to join `results` to `cases` (matching the newly-acquired "inds.b" in `cases` to rownames in `results``)  

Before the joins, we should clean the three datasets:  

* Both `dfA` and `dfB` should have their row numbers ("rowname") converted to a proper column  
* Both the columns in `my_matches` are converted to class character, so they can be joined to the character rownames  

```{r}
# Clean data prior to joining
#############################

# convert cases rownames to a column 
cases_clean <- cases %>% rownames_to_column()

# convert test_results rownames to a column
results_clean <- results %>% rownames_to_column()  

# convert all columns in matches dataset to character, so they can be joined to the rownames
matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))



# Join matches to dfA, then add dfB
###################################
# column "inds.b" is added to dfA
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))

# column(s) from dfB are added 
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```

As performed using the code above, the resulting dataframe `complete` will contain *all* columns from both `cases` and `results`. Many will be appended with suffixes ".x" and ".y", because the column names would otherwise be duplicated.  

```{r message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T))
```

Alternatively, to achieve only the "original" 9 records in `cases` with the new column(s) from `results`, use `select()` on `results` before the joins, so that it contains only rownames and the columns that you want to add to `cases` (e.g. the column `result`).  

```{r}
cases_clean <- cases %>% rownames_to_column()

results_clean <- results %>%
  rownames_to_column() %>% 
  select(rowname, result)    # select only certain columns 

matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))

# joins
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```


```{r message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T))
```


If you want to subset either dataset to only the rows that matched, you can use the codes below:  

```{r}
cases_matched <- cases[my_matches$inds.a,]  # Rows in cases that matched to a row in results
results_matched <- results[my_matches$inds.b,]  # Rows in results that matched to a row in cases
```

Or, to see only the rows that did **not** match:  

```{r}
cases_not_matched <- cases[!rownames(cases) %in% my_matches$inds.a,]  # Rows in cases that did NOT match to a row in results
results_not_matched <- results[!rownames(results) %in% my_matches$inds.b,]  # Rows in results that did NOT match to a row in cases
```


### Probabilistic deduplication  

Probabilistic matching can be used to deduplicate a dataset as well. See the page on deduplication for other methods of deduplication.  

Here we began with the `cases` dataset, but are now calling it `cases_dup`, as it has 2 additional rows that could be duplicates of previous rows:
See "Tony" with "Anthony", and "Marialisa Rodrigues" with "Maria Rodriguez".  

```{r, echo=F}
## Add duplicates
#cases_dup <- rbind(cases, cases[sample(1:nrow(cases), 3, replace = FALSE),])

cases_dup <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural",
  
  "M",     "Tony",   "B.",        "Smith",         1970, 09, 19,      "River", 
  "F",     "Maria",  "Contreras", "Rodriguez",     1972, 04, 15,      "River",
)

```

```{r message=FALSE, echo=F}
DT::datatable(cases_dup, rownames = FALSE, options = list(pageLength = nrow(cases_dup)))
```


Run the same `fastLink()` command as before, but compare the `cases_dup` dataframe to itself. When the two dataframes provided are identical, the function assumes you want to de-duplicate.  

```{r, message = F, warning = F}
## Run fastLink on the same dataset
dedupe_output <- fastLink(
  dfA = cases_dup,
  dfB = cases_dup,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district"),
  stringdist.match = c("first", "middle", "last", "district"),
  numeric.match = c("yr", "mon", "day")
)
```

`fl.out` must be of class `fastLink.dedupe`, or in other words, the result of either `fastLink()`.  

Now, you can review the potential duplicates with `getMatches()`. Provide the dataframe as both `dfA = ` and `dfB = `, and provide the output of the `fastLink()` function as `fl.out = `.  

```{r}
## Run getMatches()
cases_dedupe <- getMatches(
  dfA = cases_dup,
  dfB = cases_dup,
  fl.out = dedupe_output)
```

See the right-most column, which indicates the duplicate IDs - the final two rows are identified as being likely duplicates of rows 2 and 3.  

```{r message=FALSE, echo=F}
DT::datatable(cases_dedupe, rownames = FALSE, options = list(pageLength = nrow(cases_dedupe)))
```

To return the row numbers of rows which are likely duplicates, you can count the number of rows per unique value in the `dedupe.ids` column, and then filter to keep only those with more than one row. In this case this leaves rows 2 and 3.  

```{r}
cases_dedupe %>% 
  count(dedupe.ids) %>% 
  filter(n > 1)
```

To inspect the whole rows of the likely duplicates, put the row number in this command:  

```{r}
# displays row 2 and all likely duplicates of it
cases_dedupe[cases_dedupe$dedupe.ids == 2,]   
```





<!-- ======================================================= -->
## Resources {.tabset .tabset-fade}

The [dplyr page on joins](https://dplyr.tidyverse.org/reference/join.html)  

See this vignette on [fastLink](https://github.com/kosukeimai/fastLink) at the package's Github page  
Publication describing methodolgy of [fastLink](https://imai.fas.harvard.edu/research/files/linkage.pdf)  

Publication describing [RecordLinkage package](https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)




